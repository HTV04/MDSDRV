;======================================================================
; MDSDRV - mega drive 68k sound driver
; (C) 2019-2020 ian karlsson
;======================================================================

;======================================================================
; ABI call
;----------------------------------------------------------------------
mds_top
	bsr.w	mds_init
	bsr.w	mds_update
	bsr.w	mds_request
	bsr.w	mds_ch_dummy
	bsr.w	mds_ch_dummy
	bsr.w	mds_ch_dummy
	bsr.w	mds_ch_dummy
	bsr.w	mds_ch_dummy

;======================================================================
; ABI version string
;----------------------------------------------------------------------
version_str
	dc.b	"vaporware 200402"
;	dc.b	"MDSDRV190525V0.0"

;======================================================================
; initialize sound driver
;----------------------------------------------------------------------
; INPUT
;	a0 - pointer to work area
;   a1 - pointer to request base table (sdtop)
; TRASHES
;   a1, d0-d1
mds_init
@zero		equr d0

	move.l	a1,w_sdtop(work)				;set sdtop
	lea		mds_psg_init(pc),a1
	clr.l	@zero
	move.l	@zero,w_request(work)			;clear request
	move.l	@zero,2+w_request(work)
	move.l	@zero,w_tempo(work)				;clear tempo
	move.l	@zero,2+w_tempo(work)
	move.l	@zero,w_counter(work)			;clear counter
	move.l	@zero,2+w_counter(work)
	move.l	@zero,w_volume(work)			;clear trk volume
	move.l	@zero,2+w_volume(work)
	move.l	@zero,w_tmask(work)				;clear trk mask
	move.l	@zero,2+w_tmask(work)
	move.l	@zero,w_chmask(work)			;clear chmask
	move.l	@zero,2+w_chmask(work)
	move.w	@zero,w_fm3_mask				;clear fm3mask
	move.w	#128,w_gtempo(work)				;initial tempo
	lea		w_track(work),twork				;track addr
	move.w	#TCOUNT-1,d1
@next_track
	move.b	@zero,t_note_flag(twork)		;clear flag
	move.l	a1,t_psg_eg_addr(twork)
	move.w	#$000f,t_psg_eg_pos(twork)
	move.b	#RCOUNT<<1,t_request_id(twork)	;channel is free

	lea		TSIZE(twork),twork				;next track
	dbra	d1,@next_track

mds_halt
	stop_z80
	lea		sound_psg,a1
	move.b	#$9f,(a1)						;mute psg
	move.b	#$bf,(a1)
	move.b	#$df,(a1)
	move.b	#$ff,(a1)

	reset_z80
	start_z80
	rts

	lea		sound_fm_a0,a1
@next_part
	move.b	#$80,d1							; release rate
@rr_loop
	btst.b	#7,sound_fm_a0
	bne.s	@rr_loop
	move.b	d1,(a1)					;17 cycle wait after writing reg#
	nop
	move.b	#$0f,1(a1)						; 16 cycles + 1 nop
	addq.b	#1,d1							; next operator
	cmpi.b	#$90,d1
	bcs.s	@rr_loop
	addq.w	#2,a1
	cmpa.l	#sound_fm_a1+2,a1
	bne.s	@next_part

	subq.w	#4,a1
	move.b	#$00,d1							; key off
@keyoff_loop
	btst.b	#7,sound_fm_a0
	bne.s	@keyoff_loop
	move.b	#$28,(a1)				;17 cycle wait after writing reg#
	nop
	nop
	move.b	d1,1(a1)						; 12 cycles + 2 nops
	addq.b	#1,d1							; next channel
	cmpi.b	#$07,d1
	beq.s	@keyoff_done
	cmpi.b	#$03,d1							; ch4?
	bne.s	@keyoff_loop
	addq.b	#1,d1
	bra.s	@keyoff_loop

@keyoff_done
	start_z80
	rts

;======================================================================
; update sound driver
;----------------------------------------------------------------------
; INPUT
;	a0 - pointer to work area
; TRASHES
;   a1-a6, d0-d7
mds_update
@reqdata	equr	d0
@counter	equr	d6

	clr.w	rnum
	lea		w_track(work),twork

@next_request
	move.w	w_request(work,rnum),@reqdata
	btst	#15,@reqdata					;request flag set
	beq.s	@not_triggered
	bsr.w	mds_start_song

@not_triggered
	move.w	w_tmask(work,rnum),@reqdata
	beq.s	@request_done
	move.w	w_counter(work,rnum),@counter	;apply tempo
	add.w	w_tempo(work,rnum),@counter
	addq.w	#1,@counter
	move.w	@counter,w_counter(work,rnum)

@sequence_tick
	sub.w	w_gtempo(work),@counter			;sequence tick
	bcs.s	@request_done
	move.w	@counter,w_counter(work,rnum)
	pea		@sequence_tick(pc)
	bra.w	mds_update_seq

@request_done
	addq	#2,rnum
	cmpi.w	#RCOUNT<<1,rnum
	bne		@next_request

;----------------------------------------------------------------------
; update voices
;----------------------------------------------------------------------
mds_update_voices
@updtab		equr	tmpa2
	stop_z80

	lea		w_track(work),twork				; first track's addr
	lea		w_chmask(work),tbase			; channel mask
	move.w	#TCOUNT-1,tnum

mds_update_voices_loop
	move.w	t_note_flag(twork),flag
	bpl.s	mds_next_voice					;skip if not enabled

	movea.l	tbase,tmpa0
	move.b	t_channel_id(twork),chnid		;check priority
	move.b	t_request_id(twork),d0
	rept	RCOUNT-1
		beq.s	@has_priority
		move.w	(tmpa0)+,d1
		btst	chnid,d1
		bne.s	@no_priority
		subq.b	#2,d0						;next request
	endr
@has_priority
	bclr	#nf+nf_silence,flag
	beq.s	@no_silence
	bclr	#nf+nf_enabled,flag
@no_silence
	clr.w	d0
	add.b	chnid,chnid
	move.b	chnid,d0
	add.b	d0,d0
	add.b	chnid,d0
	jmp		mds_ch_update_table(pc,d0)
@no_priority
	clr.w	t_last_pitch(twork)
	ori.w	#nm_restore<<nf,t_note_flag(twork)
mds_next_voice
	lea		TSIZE(twork),twork				; next track
	dbra	tnum,mds_update_voices_loop

	start_z80

	rts

;======================================================================
; channel update routine table
;----------------------------------------------------------------------
; Each routine must if needed save the flags to memory and jump to
; mds_next_voice at the end.
mds_ch_mapping	macro
	moveq	\1,chnid
	bra.w	\2
	endm

mds_ch_update_table
	mds_ch_mapping	#0,mds_fm0_update		;0
	mds_ch_mapping	#1,mds_fm0_update		;1
	mds_ch_mapping	#2,mds_fm0_update		;2
	mds_ch_mapping	#4,mds_fm1_update		;3
	mds_ch_mapping	#5,mds_fm1_update		;4
	mds_ch_mapping	#6,mds_fm1_update		;5
	mds_ch_mapping	#0,mds_psg_update		;6
	mds_ch_mapping	#1,mds_psg_update		;7
	mds_ch_mapping	#2,mds_psg_update		;8
	mds_ch_mapping	#3,mds_psg_update		;9
	mds_ch_mapping	#10,mds_dummy_update	;a
	mds_ch_mapping	#11,mds_dummy_update	;b
	mds_ch_mapping	#12,mds_dummy_update	;c
	mds_ch_mapping	#13,mds_dummy_update	;d
	mds_ch_mapping	#14,mds_dummy_update	;e
	mds_ch_mapping	#15,mds_dummy_update	;f

;======================================================================
; Request track
;----------------------------------------------------------------------
; INPUT
;	a0 - pointer to work area
;	d0 - request track
;	d1 - request priority, range 0-3.
; TRASHES
;	d0,d1
mds_request
	bset	#15,d0
	andi.w	#3,d1
	lsl.w	d1
	move.w	d0,w_request(a0,d1)
	rts

;======================================================================
; stops song playback
;----------------------------------------------------------------------
; INPUT
;   twork - track's working area
; OUTPUT
;   -
; TRASHES
;	d1,d6
mds_stop_song
	lea		w_track(work),twork
	move.w	#TCOUNT-1,tnum
	move.w	w_tmask(work,rnum),tmask

@next_track
	btst	tnum,tmask						;track id
	beq.w	@skip_track
	ori.b	#nm_stop,t_note_flag(twork)
	bset	#cf_inhibit,t_channel_flag(twork)
	move.b	#RCOUNT<<1,t_request_id(twork)	;track is free

@skip_track
	lea		TSIZE(twork),twork				;next track
	dbra	tnum,@next_track
	clr.w	w_tmask(work,rnum)				;clear trackmask
	clr.w	w_chmask(work,rnum)				;clear chmask
@exit
	rts

;======================================================================
; starts song playback
;----------------------------------------------------------------------
; INPUT
;   twork - track's working area
;   d0 - request #
; OUTPUT
;   -
; TRASHES
;	d0-d3, tmpa0, tmpa1
mds_start_song
@reqdata	equr	d0						;request id
@tempo		equr	d1						;global tempo
@zero		equr	d1
@tempreg	equr	d2

	bclr	#15,@reqdata
	move.w	@reqdata,w_request(work,rnum)	;clear request flag
	bsr.w	mds_stop_song					;stop already playing song

	subq.w	#1,@reqdata						;subtract sound codes
	bmi		@exit							;0 to stop a track

	lea		mds_psg_init(pc),tmpa1

	move.w	w_gtempo(work),@tempo
	subq.w	#1,@tempo
	move.w	@tempo,w_tempo(work,rnum)		;initial tempo
	clr.w	@zero
	move.w	@zero,w_counter(work,rnum)

	lsl.w	#2,@reqdata						;request table
	move.l	w_sdtop(work),tmpa0				;location of song header
	adda.l	0(tmpa0,@reqdata),tmpa0

	move.l	tmpa0,tbase
	adda.w	(tmpa0)+,tbase					;song base offset
	move.w	(tmpa0)+,w_tmask(work,rnum)		;track mask
	lea		w_track(work),twork
	move.w	#TCOUNT-1,tnum
	move.w	w_tmask(work,rnum),tmask

@next_track
	btst	tnum,tmask
	beq.w	@skip_track

	move.l	tbase,t_base_addr(twork)
	move.b	(tmpa0)+,@reqdata				;channel id
	move.b	#nm_init,t_note_flag(twork)
	move.b	(tmpa0)+,t_channel_flag(twork)
	lsl.w	#8,@reqdata
	or.w	rnum,@reqdata
	move.w	@reqdata,t_channel_id(twork)

	clr.w	@tempreg						;allocate channel
	bset	@reqdata,@tempreg
	or.w	@tempreg,w_chmask(work,rnum)

	cmp.w	#ct_psg<<8,@reqdata
	bcs.s	@not_psg

	move.l	tmpa1,t_psg_eg_addr(twork)		;psg eg initialize
	move.w	#$000f,t_psg_eg_pos(twork)
	bra.s	@not_fm

@not_psg
	move.b	#$c0,t_fm_pan_lfo(twork)		;initial panning

@not_fm
	move.w	@zero,t_last_pitch(twork)		;previous pitch
	move.w	@zero,t_note(twork)				;note/transpose
	move.w	@zero,t_trs(twork)				;transpose/portamento
	move.w	#$8f00,t_vol(twork)				;vol/lfo_delay

	move.w	@zero,t_peg_addr(twork)			;pitch e.g.
	move.w	@zero,t_peg_mod(twork)			;pitch e.g.
	move.w	(tmpa0)+,t_position(twork)		;start position
	move.w	@zero,t_stack_pos(twork)		;stack_pos & counter
	move.w	#$0b0b,t_rest_time(twork)		;default time (-1)
	move.b	@zero,t_stack_pos(twork)

@skip_track
	lea		TSIZE(twork),twork				;next track
	dbra	tnum,@next_track
@exit
	rts

;======================================================================
; update track sequences
;----------------------------------------------------------------------
; INPUT
;   twork - track's working area
; OUTPUT
;   -
; TRASHES
;	?
mds_update_seq
@trackpos	equr	d0
@cmd		equr	d1
@cmdlen		equr	d2
@tempreg	equr	d3

	lea		w_track(work),twork				; first track's addr
	swap	tnum							; backup tempo counter
	move.w	#TCOUNT-1,tnum
	move.w	w_tmask(work,rnum),tmask

@next_track
	btst	tnum,tmask						; track enabled?
	beq.s	@command_done

	subq.b	#1,t_counter(twork)
	bcs.s	@read_command					; counter overflow

@command_done
	lea		TSIZE(twork),twork				; next track
	dbra	tnum,@next_track
	swap	tnum							; restore tempo counter
	rts

;----------------------------------------------------------------------
; command read loop
;----------------------------------------------------------------------
@read_command
	move.l	t_base_addr(twork),tbase
	move.w	t_position(twork),@trackpos
	moveq	#1,@cmdlen

@next_command
	add.w	@cmdlen,@trackpos
	move.b	-1(tbase,@trackpos),@cmd
	bmi.s	@cmd_80

@cmd_rest
	bset	#nf_key_off,t_note_flag(twork)
	move.b	@cmd,t_rest_time(twork)			;00-7f - rest
	move.b	@cmd,t_counter(twork)
	move.w	@trackpos,t_position(twork)
	bra.s	@command_done

@cmd_80
	sub.b	#$81,@cmd						;81 - tie
	beq.s	@cmd_tie
	addq.b	#1,@cmd
	beq.s	@cmd_rest2						;80 - rest (alternate)
	cmp.b	#$60,@cmd
	bcc.s	@cmd_other

	subq.b	#2,@cmd							;82-df - note
	move.b	@cmd,t_note(twork)
	bset	#nf_key_on,t_note_flag(twork)
	btst	#nf_slur,t_note_flag(twork)
	bne.s	@cmd_tie
	bset	#nf_key_off,t_note_flag(twork)
;----------------------------------------------------------------------
; TODO: drum mode jump here
;----------------------------------------------------------------------
@cmd_tie
	lea		t_note_time(twork),tmpa0
@cmd_read_delta
	move.b	0(tbase,@trackpos),@cmd			;read next command
	bmi		@cmd_previous_delta

@cmd_new_delta
	move.b	@cmd,t_counter(twork)
	move.b	@cmd,(tmpa0)
	addq.w	#1,@trackpos
	move.w	@trackpos,t_position(twork)
	bra.s	@command_done

@cmd_previous_delta
	move.b	(tmpa0),t_counter(twork)
	move.w	@trackpos,t_position(twork)
	bra.s	@command_done

@cmd_rest2
	bset	#nf_key_off,t_note_flag(twork)	;80 - rest 2
	move.b	t_rest_time(twork),t_counter(twork)
	move.w	@trackpos,t_position(twork)
	bra.w	@command_done

@cmd_other
	andi.w	#$1f,@cmd
	move.b	@cmd_length_table(pc,@cmd),@cmdlen
	lsl.b	#2,@cmd
	pea		@next_command(pc)
	jmp		@cmd_table(pc,@cmd)

;----------------------------------------------------------------------
; command table
;----------------------------------------------------------------------
@cmd_length_table
	dc.b	1,2,2,2, 2,2,2,2, 2,2,2,2, 2,3,2,2		;e0
	dc.b	2,0,0,0, 0,0,3,0, 2,2,1,2, 2,3,1,0		;f0
@cmd_table
	bra.w	@cmd_slr						;e0 slur
	bra.w	@cmd_ins						;e1 instrument
	bra.w	@cmd_vol						;e2 volume
	bra.w	@cmd_volm						;e3 volume change
	bra.w	@cmd_trs						;e4 transpose
	bra.w	@cmd_trsm						;e5 transpose change
	bra.w	@cmd_dtn						;e6 detune
	bra.w	@cmd_pta						;e7 portamento
	bra.w	@cmd_peg						;e8 pitch envelope
	bra.w	@cmd_pan						;e9 panning
	bra.w	@cmd_lfo						;ea lfo sensitivity
	bra.w	@cmd_lfod						;eb lfo delay
	bra.w	@cmd_flg						;ec channel flags
	bra.w	@cmd_fmcreg						;ed fm channel reg write
	bra.w	@cmd_fmtl						;ee fm tl write
	bra.w	@cmd_fmtlm						;ef fm tl change
	bra.w	@cmd_finish						;f0 ** reserved for pcm ins
	bra.w	@cmd_finish						;f1
	bra.w	@cmd_finish						;f2
	bra.w	@cmd_finish						;f3
	bra.w	@cmd_finish						;f4
	bra.w	@cmd_finish						;f5
	bra.w	@cmd_fmreg						;f6 fm register write
	bra.w	@cmd_dmfinish					;f7 drum mode finish
	bra.w	@cmd_comm						;f8 communication byte
	bra.w	@cmd_tempo						;f9 tempo
	bra.w	@cmd_lp							;fa loop
	bra.w	@cmd_lpf						;fb loop finish
	bra.w	@cmd_lpb						;fc loop break
	bra.w	@cmd_lpbl						;fd loop break 2
	bra.w	@cmd_pat						;fe subroutine
@cmd_finish									;ff finish
	move.b	t_stack_pos(twork),@cmd
	bne		@cmd_return

	ori.b	#nm_stop,t_note_flag(twork)
	bset	#cf_inhibit,t_channel_flag(twork)
	move.b	#RCOUNT<<1,t_request_id(twork)	;track is free

	moveq	#-1,@tempreg					;clear channel mask
	bclr	tnum,@tempreg
	and.w	@tempreg,w_tmask(work,rnum)

	moveq	#-1,@tempreg					;deallocate channel
	move.b	t_channel_id(twork),@cmd
	bclr	@cmd,@tempreg
	and.w	@tempreg,w_chmask(work,rnum)

	addq.w	#4,sp							;break out of command
	move.w	@trackpos,t_position(twork)
	bra.w	@command_done

@cmd_return
	subq.b	#2,@cmd
	move.b	@cmd,t_stack_pos(twork)
	move.w	t_stack(twork,@cmd),@trackpos	; pop return address
@cmd_dummy
	rts

;----------------------------------------------------------------------
; slr - set note slur
;----------------------------------------------------------------------
@cmd_slr
	bset	#nf_slur,t_note_flag(twork)
	rts

;----------------------------------------------------------------------
; ins - set instrument (or PSG envelope)
;----------------------------------------------------------------------
; CAUTION: instrument data must fit within 32k of w_sdtop address
;  due to the "movea @cmd,tmpa0"
;----------------------------------------------------------------------
@cmd_ins
	move.b	0(tbase,@trackpos),@cmd
	move.b	@cmd,t_ins(twork)
	bset	#nf_ins,t_note_flag(twork)
	lsl.w	@cmd
	movea.w	0(tbase,@cmd),tmpa0				; instr address
	move.b	t_channel_id(twork),@cmd
	cmpi.b	#6,@cmd							; fm or psg
	bcc.s	@cmd_ins_psg
	adda.l	w_sdtop(work),tmpa0				; ptr. to ins data
	bset	#nf_key_off,t_note_flag(twork)
	move.l	24(tmpa0),t_fm_tl(twork)
	move.b	28(tmpa0),t_fm_alg(twork)
	move.b	29(tmpa0),t_ins_trs(twork)
	rts

@cmd_ins_psg
	move.w	tmpa0,t_psg_eg_addr(twork)
	move.w	#$000f,t_psg_eg_pos(twork)
	rts

;----------------------------------------------------------------------
; vol - set volume
;----------------------------------------------------------------------
@cmd_vol
	move.b	0(tbase,@trackpos),t_vol(twork)
	bset	#nf_vol,t_note_flag(twork)
	rts
@cmd_volm
	move.b	0(tbase,@trackpos),@cmd
	add.b	@cmd,t_vol(twork)
	bset	#nf_vol,t_note_flag(twork)
	rts

;----------------------------------------------------------------------
; vol - set transpose
;----------------------------------------------------------------------
@cmd_trs
	move.b	0(tbase,@trackpos),t_trs(twork)
	rts
@cmd_trsm
	move.b	0(tbase,@trackpos),@cmd
	add.b	@cmd,t_trs(twork)
	rts

;----------------------------------------------------------------------
; dtn - set detune
;----------------------------------------------------------------------
@cmd_dtn
	move.b	0(tbase,@trackpos),t_dtn(twork)
	rts

;----------------------------------------------------------------------
; pta - set portamento
;----------------------------------------------------------------------
@cmd_pta
	move.b	0(tbase,@trackpos),t_pta(twork)
	rts

;----------------------------------------------------------------------
; peg - set pitch envelope
;----------------------------------------------------------------------
@cmd_peg
	clr.w	@cmd
	move.w	@cmd,t_peg_mod(twork)
	move.w	@cmd,t_peg_delay(twork)					;also clears pos
	move.b	0(tbase,@trackpos),@cmd
	beq.s	@cmd_peg_off
	lsl.w	#1,@cmd
	move.w	0(tbase,@cmd),t_peg_addr(twork)
	rts
@cmd_peg_off
	move.w	@cmd,t_peg_addr(twork)
	rts

;----------------------------------------------------------------------
; pan - set panning
;----------------------------------------------------------------------
; bit 6 = enable left speaker
; bit 7 = enable right speaker
;----------------------------------------------------------------------
@cmd_pan
	move.b	t_fm_pan_lfo(twork),@cmd
	andi.b	#$c0,@cmd
	or.b	0(tbase,@trackpos),@cmd
	move.b	@cmd,t_fm_pan_lfo(twork)
	bset	#nf_pan_lfo,t_note_flag(twork)
	rts

;----------------------------------------------------------------------
; lfo - set lfo depth (channel specific setting)
;----------------------------------------------------------------------
; bit 0-1 = FM sensitivity
; bit 3-5 = AM sensitivity
;----------------------------------------------------------------------
@cmd_lfo
	move.b	t_fm_pan_lfo(twork),@cmd
	andi.b	#$3f,@cmd
	or.b	0(tbase,@trackpos),@cmd
	move.b	@cmd,t_fm_pan_lfo(twork)
	bset	#nf_pan_lfo,t_note_flag(twork)
	rts

;----------------------------------------------------------------------
; lfod - set lfo delay
;----------------------------------------------------------------------
@cmd_lfod
	move.b	0(tbase,@trackpos),t_lfo_delay(twork)
	rts

;----------------------------------------------------------------------
; flg - set channel flags
;----------------------------------------------------------------------
; 00-07 - clear flag
; 08-0F - set flag
; 80-8F - ch3 mask set
;----------------------------------------------------------------------
@cmd_flg
	clr.w	@cmd
	move.b	0(tbase,@trackpos),@cmd
	bmi.s	@cmd_flg_fm3					; bit7 set = fm3 flags
	btst	#4,@cmd							; bit4 set = set a flag
	beq.s	@cmd_flg_off
	bset	@cmd,t_channel_flag(twork)
	rts
@cmd_flg_off
	bclr	@cmd,t_channel_flag(twork)
	rts
@cmd_flg_fm3
	tst.b	@cmd
	beq.s	@cmd_flg_fm3_off
	bset	#cf_fm3_enable,t_channel_flag(twork)
	move.b	@cmd,t_fm3_mask(twork)	; we're reusing MSB of t_base_addr
	rts
@cmd_flg_fm3_off
	bclr	#cf_fm3_enable,t_channel_flag(twork)
	rts

;----------------------------------------------------------------------
; fmreg - write to FM chip
;----------------------------------------------------------------------
@cmd_fmreg
	rts
@cmd_fmcreg
	rts

;----------------------------------------------------------------------
; fmtl - set FM TL
;----------------------------------------------------------------------
@cmd_fmtl
	rts
@cmd_fmtlm
	rts

;----------------------------------------------------------------------
; comm - communication byte
;----------------------------------------------------------------------
@cmd_comm
	rts

;----------------------------------------------------------------------
; tempo - set song tempo
;----------------------------------------------------------------------
@cmd_tempo
	clr.w	@cmd
	move.b	0(tbase,@trackpos),@cmd
	move.w	@cmd,w_tempo(work,rnum)
	rts

;----------------------------------------------------------------------
; lp - loop start
;----------------------------------------------------------------------
@cmd_lp
	move.b	t_stack_pos(twork),@cmd
	move.b	#$ff,t_stack(twork,@cmd)
	move.w	@trackpos,2+t_stack(twork,@cmd)
	addq.b	#4,@cmd
@cmd_lpf_exit
	move.b	@cmd,t_stack_pos(twork)
	rts

;----------------------------------------------------------------------
; lpf - loop finish
;----------------------------------------------------------------------
@cmd_lpf
	move.b	t_stack_pos(twork),@cmd
	subq.b	#4,@cmd
	move.b	t_stack(twork,@cmd),@tempreg
	cmpi.b	#$ff,@tempreg
	bne.s	@cmd_lpf_decrease
	move.b	0(tbase,@trackpos),@tempreg
@cmd_lpf_decrease
	subq.b	#1,@tempreg
	beq.s	@cmd_lpf_exit
	move.b	@tempreg,t_stack(twork,@cmd)
	move.w	2+t_stack(twork,@cmd),@trackpos
	moveq	#1,@cmdlen
	rts

;----------------------------------------------------------------------
; lpb - loop break
;----------------------------------------------------------------------
@cmd_lpb
	move.b	t_stack_pos(twork),@cmd
	subq.b	#4,@cmd  ;optimize with stack-4?
	tst.b	t_stack(twork,@cmd)
	bne.s	@cmd_lpb_skip
	add.b	0(tbase,@trackpos),@cmdlen
	move.b	@cmd,t_stack_pos(twork)
@cmd_lpb_skip
	rts

;----------------------------------------------------------------------
; lpbl - loop break (long)
;----------------------------------------------------------------------
@cmd_lpbl
	move.b	t_stack_pos(twork),@cmd
	subq.b	#4,@cmd
	tst.b	t_stack(twork,@cmd)
	bne.s	@cmd_lpb_skip
	move.b	0(tbase,@trackpos),@tempreg ;no need to align 16-bit
	lsl.w	#8,@tempreg
	move.b	1(tbase,@trackpos),@tempreg
	add.w	@tempreg,@cmdlen
	move.b	@cmd,t_stack_pos(twork)
	rts

;----------------------------------------------------------------------
; pat - subroutine
;----------------------------------------------------------------------
@cmd_pat
	move.b	t_stack_pos(twork),@cmd
	move.w	@trackpos,@cmd
	addq.b	#4,@cmd
	move.b	@cmd,t_stack_pos(twork)
	move.b	0(tbase,@trackpos),@cmd
	lsl.w	#1,@cmd
	move.w	0(tbase,@cmd),@trackpos				; subroutine address
	rts

;----------------------------------------------------------------------
; dmfinish - drum mode finish byte
;----------------------------------------------------------------------
@cmd_dmfinish
	rts

;======================================================================
; check channel priority
;----------------------------------------------------------------------
; INPUT
;   d0 - channel id
; OUTPUT
;   d0 - request # with highest priority
; TRASHES
;	tmpa0, d1, d2
mds_check_priority
	move.w	d0,d2
	clr.w	d0
	lea		w_chmask(work),tmpa0
	rept	RCOUNT
		move.w	(tmpa0)+,d1
		btst	d2,d1
		bne		@end
		addq.b	#2,d0						;next request
	endr
@end
	rts

;======================================================================
; get FM pitch
;----------------------------------------------------------------------
; INPUT
;   d0 - key code + fraction
; OUTPUT
;   d0 - pitch value
; TRASHES
;   tmpa1, d1, d2
mds_get_fm_pitch
	lsl.l	#8,d0
	move.w	d0,d1							; upper bits of keycode
	swap	d0
	lea		mds_octave_table(pc),tmpa1
	move.b	0(tmpa1,d0),d2					; octave
	move.b	mds_note_table-mds_octave_table(tmpa1,d0),d0
	add.b	t_ins_trs(twork),d0				;freq tab displacement
	lea		@fm_freq_tab(pc,d0),tmpa1
	move.w	2(tmpa1),d0
	sub.w	(tmpa1),d0
	mulu	d1,d0							;interpolate
	swap	d0
	add.w	(tmpa1),d0
	rol.w	#8,d0
	add.b	d2,d0							;octave added
	rts
@fm_freq_tab
	dc.w 161,171,181,191,203,215,228,241,255,271,287,304		; 0-11
	dc.w 322,341,361,383,406,430,455,482,511,541,574,608		; 12-23
	dc.w 644,682,723,766,811,859,910,965,1022,1083,1147,1215	; 24-35
	dc.w 1288,1364,1445,1531,1622,1719,1821,1929,2044			; 36-45

;======================================================================
; get PSG pitch
;----------------------------------------------------------------------
; INPUT
;   d0 - key code + fraction
; OUTPUT
;   d0 - pitch value
; TRASHES
;   tmpa0, d1, d2
mds_get_psg_pitch
	lsl.l	#8,d0
	move.w	d0,d1							; upper bits of keycode
	swap	d0
	lea		mds_octave_table(pc),tmpa0
	move.b	0(tmpa0,d0),d2					; octave
	move.b	mds_note_table-mds_octave_table(tmpa0,d0),d0
	lea		@psg_freq_tab(pc,d0),tmpa0
	move.w	2(tmpa0),d0
	sub.w	(tmpa0),d0
	ext.w	d1
	mulu	d1,d0							;interpolate
	swap	d0
	add.w	(tmpa0),d0
	lsr.b	#3,d2
	lsr.l	d2,d0							;octave shifted
	rts
@psg_freq_tab
	dc.w	851,803,758,715,675,637,601,568,536,506,477,450,425

;======================================================================
; Note/octave division table
;----------------------------------------------------------------------
; note values are multiplied by 2 since they are likely going to be
; used as LUT indices
mds_octave_table
	dcb.b   12,0  ;0
	dcb.b	12,8  ;12
	dcb.b	12,16 ;24
	dcb.b	12,24 ;36
	dcb.b	12,32 ;48
	dcb.b	12,40 ;60
	dcb.b	12,48 ;72
	dcb.b	12,56 ;84
mds_note_table
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22

;======================================================================
; PSG envelope initialize
;----------------------------------------------------------------------
mds_psg_init
	dc.b	$10,$01,$1f,$00

;======================================================================
; dummy routine
;----------------------------------------------------------------------
mds_ch_dummy
	rts

;======================================================================
; Pitch update
;----------------------------------------------------------------------
; INPUT
;  work, twork
; OUTPUT
;  d0 - calculated pitch
; TRASHES
;  tmpa1,d1,d2,d3,d4
mds_pitch_update
	move.b	t_note(twork),d1
	add.b	t_trs(twork),d1
	lsl.w	#8,d1
	move.b	t_dtn(twork),d0							; signed value
	ext.w	d0
	add.w	d1,d0									; d0=porta_target

;----------------------------------------------------------------------
; portamento update
;----------------------------------------------------------------------
	clr.w	d3
	move.b	t_pta(twork),d3
	beq.s	@porta_done

	move.w	d0,d2
	sub.w	t_pitch(twork),d2						;d2=porta_delta
	beq.s	@porta_done

	move.w	d2,d1									;get step
	asr.w	#8,d1
	bpl.s	@add_step
	subq.w	#2,d1
@add_step
	addq.w	#1,d1

	muls	d3,d1
	add.w	t_pitch(twork),d1						;d1=new_pitch

	move.w	d0,d3
	sub.w	d1,d3
	eor.w	d2,d3
	bmi.s	@porta_done
	move.w	d1,d0
@porta_done
	move.w	d0,t_pitch(twork)

;----------------------------------------------------------------------
; pitch envelope update
;----------------------------------------------------------------------
	move.w	t_peg_addr(twork),d1
	beq.s	@no_peg

	btst	#nf+nf_key_on,flag
	beq.s	@no_retrig
	clr.w	t_peg_delay(twork)
@no_retrig

	movea.w	d1,tmpa1
	adda.l	w_sdtop(work),tmpa1

	clr.w	d1
	move.b	t_peg_pos(twork),d1
	lsl.w	#2,d1
	move.w	t_peg_mod(twork),d2						;d2=modulator

	move.b	t_peg_delay(twork),d3
	bne.s	@no_reset
	move.w	0(tmpa1,d1),d2							;d2=init modulator

@no_reset
	move.b	2(tmpa1,d1),d4
	ext.w	d4
	add.w	d2,d4									;add delta
	move.w	d4,t_peg_mod(twork)
	add.w	d4,d0

	cmp.b	3(tmpa1,d1),d3							;delay done?
	bne.s	@delay_not_done

	move.w	4(tmpa1,d1),d2							;next command
	subi.w	#$7f00,d2
	blt.s	@no_jump

	move.w	d2,t_peg_delay(twork)					;jump to position
@no_peg
	rts

@no_jump
	lsr.w	#2,d1
	addq.b	#1,d1
	move.w	d1,t_peg_delay(twork)					;next position
	rts

@delay_not_done
	addq.b	#1,d3									;increase delay
	beq.s	@no_peg									; ff = endless
	move.b	d3,t_peg_delay(twork)
	rts

;======================================================================
; FM patch upload
;----------------------------------------------------------------------
; NOTE: does not wait for the FM busy flag to clear at the beginning
;       of this routine
; INPUT:
;  tmpa0 - FM write address
;  tmpa1 - instrument data address
;  chnid - FM logical channel #
; TRASHES
;  tmpa1,d0,d1,d2,d3
mds_fm_update_ins
@fm			equr	tmpa0
	move.w	chnid,d1
	andi.b	#$03,d1
	swap	chnid

;----------------------------------------------------------------------
; channel mute
;----------------------------------------------------------------------
; optimization: rather than checking the busy flag we could just wait
; the mandated number of cycles between writes = 83 according to YM2608
; manual
	move.b	#$40,d0								;tl=max
	add.b	d1,d0
	moveq	#3,d2								;op count
	bra.s	@notbusy
@nextop											; burn 83-14 = 69
	bsr.s	@burn56								;     56 : 56
@notbusy:
	move.b	d0,0(@fm,chnid)						;     14 : 70
	move.b	#$7f,1(@fm,chnid)					;        : 18
	addq.b	#4,d0								;  10/14 : 18 (14)
	dbra	d2,@nextop							;  10/14 : 32

;----------------------------------------------------------------------
; load inst data
;----------------------------------------------------------------------
	lea		@op_reg_table(pc),tmpa2				;      8
	moveq	#5,d3								;      4

@nextreg
	move.b	(tmpa2)+,d0							;      8
	add.b	d1,d0								;      4
	moveq	#3,d2								;      4
@nextop2										; burn 83-14 = 69
	bsr.s	@burn56								;     56 : 56
	move.b	d0,0(@fm,chnid)						;     14 : 70
	move.b	(tmpa1)+,1(@fm,chnid)				;       : 18
	addq.b	#4,d0								;      4 :  4
	dbra	d2,@nextop2							;  10/14 : 18 (14)
	dbra	d3,@nextreg							;  10/14 : 32

;----------------------------------------------------------------------
; load feedback/algorithm
;----------------------------------------------------------------------
												; burn 83-32 = 51
	addq.w	#4,tmpa1							;      8 :  8
	move.b	#$b0,d0								;      8 : 16
	add.b	d1,d0								;      4 : 20
	cmp.b	sound_fm_a0,d0						;12+4=16 : 36
	move.b	d0,0(@fm,chnid)						;     14 : 52
	move.b	(tmpa1)+,1(@fm,chnid)				;        : 18
	swap	chnid
	rts

;----------------------------------------------------------------------
; burn cycles while FM chip is busy
;----------------------------------------------------------------------
@burn56											; bsr=18 : 18
	cmp.b	*(pc,d0),d0							;10+4=14 : 32
	nop											;      4 : 36
	nop											;      4 : 40
	rts											;     16 : 56

;----------------------------------------------------------------------
; operator register table
;----------------------------------------------------------------------
@op_reg_table
	dc.b	$30,$50,$60,$70,$80,$90

;======================================================================
; FM volume update
;----------------------------------------------------------------------
; NOTE: does not wait for the FM busy flag to clear at the beginning
;       of this routine
; INPUT:
;  tmpa0 - FM write address
;  chnid - FM logical channel #
; TRASHES
;  tmpa1,tmpa2,d0,d1,d2,d3,d4
mds_fm_update_vol
@fm			equr	tmpa0
	lea		4+t_fm_tl(twork),tmpa1
	move.b	t_vol(twork),d3
	bpl.s	@no_vol_table
	cmpi.b	#$90,d3
	bcc.s	@no_vol_table
	andi.w	#$000f,d3
	move.b	mds_fm_vol_table(pc,d3),d3

@no_vol_table
	move.b	t_fm_alg(twork),d4
	andi.w	#$0007,d4

	moveq	#3,d2
	move.w	chnid,d1
	and.b	d2,d1
	add.b	#$4c,d1
	swap	chnid
@nextop											; burn 83-14 = 69
	move.b	-(tmpa1),d0							;      10 : 10
	cmp.b	mds_fm_op_table(pc,d4),d2			; 10+4=14 : 24
	bcs.s	@modulator							;    10/8 : 32
	add.b	d3,d0								;       4 : 36
	bpl.b	@no_overflow						;    10/8 : 44
	move.b	#$7f,d0								;       8 : 52
	bra.s	@write_vol							;      10 : 62
@modulator										;           34
	cmp.b	*(pc),d0							;  8+4=12 : 46
@no_overflow									;           46
	cmp.b	*(pc),d0							;  8+4=12 : 58
@write_vol										;           58 to 62
	move.b	d1,0(@fm,chnid)						;      14 : 72-76
	nop											;       4 :  4
	move.b	d0,1(@fm,chnid)						;      14 : 18
	subq.b	#4,d1								;       4 :  4
	dbra	d2,@nextop							;   10/14 : 18 (14)
	swap	chnid
	rts

;======================================================================
; FM volume calculation tables
;----------------------------------------------------------------------
mds_fm_op_table
	dc.b	3,3,3,3,2,1,1,0
mds_fm_vol_table
	dc.b	42,40,37,34,32,29,26,24,21,18,16,13,10,8,5,2

;======================================================================
; FM update
;----------------------------------------------------------------------
; INPUT:
;  work, twork, chnid
; TRASHES:
;  chnid
mds_fm1_update
	bset	#17,chnid								; use second port
mds_fm0_update
@fm			equr	tmpa0
	lea		sound_fm_a0,@fm
;----------------------------------------------------------------------
; key_off update
;----------------------------------------------------------------------
	bclr	#nf+nf_key_off,flag
	beq.s	@no_key_off
;TODO: FM3, pcm

@busy0
	btst.b	#7,(@fm)
	bne.s	@busy0
	move.b	#$28,(@fm)
	nop
	nop
	move.b	chnid,1(@fm)						;12 cycles + 2 nop

@no_key_off
;----------------------------------------------------------------------
; instrument update
;----------------------------------------------------------------------
; this code should burn enough cycles (92) to make it necessary not to
; wait for busy flag in mds_fm_upload.
	bclr	#nf+nf_ins,flag
	beq.s	@no_ins

	move.b	t_ins(twork),d0
	lsl.w	d0
	move.l	t_base_addr(twork),tmpa1
	movea.w	0(tmpa1,d0),tmpa1
	adda.l	w_sdtop(work),tmpa1					; ptr. to ins data
	bsr.w	mds_fm_update_ins
	bclr	#nf+nf_vol,flag
	bra.s	@update_vol

@no_ins
;----------------------------------------------------------------------
; vol update
;----------------------------------------------------------------------
	bclr	#nf+nf_vol,flag
	beq.s	@no_vol

@update_vol
	bsr.w	mds_fm_update_vol

@no_vol
;----------------------------------------------------------------------
; pitch update
;----------------------------------------------------------------------
	bsr.w	mds_pitch_update
	cmp.w	t_last_pitch(twork),d0
	beq.s	@no_write_pitch

	move.w	d0,d3
	bsr.w	mds_get_fm_pitch
	move.b	chnid,d1
	swap	chnid
	andi.b	#3,d1
	addi.b	#$a4,d1
	move.b	d1,0(@fm,chnid)
	nop
	move.b	d0,1(@fm,chnid)						; 4+14 : 18
	ror.w	#8,d0								; 22  :  22
	subq.b	#4,d1								;  4  :  28
	move.w	d3,t_last_pitch(twork)				; 12  :  40
	move.b	d1,0(@fm,chnid)						; 14  :  54
	nop
	move.b	d0,1(@fm,chnid)						; 4+14 : 18
	swap	chnid

@no_write_pitch
;----------------------------------------------------------------------
; pan_lfo update
;----------------------------------------------------------------------
	bclr	#nf+nf_pan_lfo,flag
	beq.s	@no_lfo
	move.b	t_fm_pan_lfo(twork),d0
	move.b	chnid,d1
	swap	chnid
	andi.b	#3,d1
	addi.b	#$b4,d1
	move.b	d1,0(@fm,chnid)
	nop
	move.b	d0,1(@fm,chnid)						; 4+14 : 18
	swap	chnid

@no_lfo
;----------------------------------------------------------------------
; key_on update
;----------------------------------------------------------------------
	bclr	#nf+nf_key_on,flag
	beq.s	@no_key_on

	btst	#cf+cf_fm3_enable,flag
	beq.s	@no_fm3_key_on						; TODO: fm3_keyon

	move.w	flag,t_note_flag(twork)
	bra.w	mds_next_voice

@no_fm3_key_on
;	btst	#cf+cf_pcm_control,flag				; TODO: pcm_keyon

	bclr	#nf+nf_slur,flag
	bne.s	@no_key_on

	move.b	#$28,(@fm)
	move.b	chnid,d0							; 4 :  4
	ori.b	#$f0,d0								; 8 : 12
	move.b	d0,1(@fm)							;12 : 24

@no_key_on

	move.w	flag,t_note_flag(twork)
	bra.w	mds_next_voice

;======================================================================
; PSG update
;----------------------------------------------------------------------
mds_psg_update
	move.w	flag,t_note_flag(twork)
	bra.w	mds_next_voice

;======================================================================
; Dummy channel update (only check for FM3)
;----------------------------------------------------------------------
mds_dummy_update
	move.w	flag,t_note_flag(twork)
	bra.w	mds_next_voice

; vim: set ft=asm68k sw=4 ts=4 noet:
