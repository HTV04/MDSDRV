;======================================================================
; MDSDRV - mega drive 68k sound driver
; (C) 2019-2020 ian karlsson
;======================================================================

;======================================================================
; ABI call
;----------------------------------------------------------------------
mds_top
	bsr.w	mds_init
	bsr.w	mds_update
	bsr.w	mds_request
	bsr.w	mds_ch_dummy
	bsr.w	mds_ch_dummy
	bsr.w	mds_ch_dummy
	bsr.w	mds_ch_dummy
	bsr.w	mds_ch_dummy

;======================================================================
; ABI version string
;----------------------------------------------------------------------
version_str
	dc.b	"vaporware 200406"
;	dc.b	"MDSDRV190525V0.0"

;======================================================================
; initialize sound driver
;----------------------------------------------------------------------
; INPUT
;	a0 - pointer to work area
;   a1 - pointer to request base table (sdtop)
; TRASHES
;   a0-a1, d0-d1
mds_init
@zero		equr d0

	move.l	a1,w_sdtop(work)				;set sdtop
	lea		mds_psg_init(pc),a1
	clr.l	@zero
	move.l	@zero,w_request(work)			;clear request
	move.l	@zero,2+w_request(work)
	move.l	@zero,w_tempo(work)				;clear tempo
	move.l	@zero,2+w_tempo(work)
	move.l	@zero,w_counter(work)			;clear counter
	move.l	@zero,2+w_counter(work)
	move.l	@zero,w_seq_step(work)			;clear seq step
	move.l	@zero,2+w_seq_step(work)
	move.l	@zero,w_volume(work)			;clear trk volume
	move.l	@zero,2+w_volume(work)
	move.l	@zero,w_tmask(work)				;clear trk mask
	move.l	@zero,2+w_tmask(work)
	move.l	@zero,w_chmask(work)			;clear chmask
	move.l	@zero,2+w_chmask(work)
	move.w	@zero,w_fm3_mask				;clear fm3mask
	move.w	#128,w_gtempo(work)				;initial tempo
	lea		w_track(work),twork				;track addr
	move.w	#TCOUNT-1,d1
@next_track
	move.b	@zero,t_note_flag(twork)		;clear flag
	move.l	a1,t_psg_eg_addr(twork)
	move.w	#$000f,t_psg_eg_pos(twork)
	move.b	#RCOUNT<<1,t_request_id(twork)	;channel is free

	lea		TSIZE(twork),twork				;next track
	dbra	d1,@next_track

mds_halt
	stop_z80
	lea		sound_psg,a1
	move.b	#$9f,(a1)						;mute psg
	move.b	#$bf,(a1)
	move.b	#$df,(a1)
	move.b	#$ff,(a1)

	lea		mds_z80_driver(pc),a0
	lea		z80_ram,a1
	move.w	#mds_z80_driver_size-1,d0
@z80_loop
	move.b	(a0)+,(a1)+
	dbra	d0,@z80_loop

	reset_z80
	start_z80
	rts

;======================================================================
; update sound driver
;----------------------------------------------------------------------
; INPUT
;	a0 - pointer to work area
; TRASHES
;   a1-a6, d0-d7
mds_update
@reqdata	equr	d0
@counter	equr	d0
@seq_step	equr	d1
@gtempo		equr	d2

	clr.l	rnum
	lea		w_track(work),twork

@next_request
	move.w	w_request(work,rnum),@reqdata
	bmi.w	mds_handle_request

;----------------------------------------------------------------------
mds_handle_request_return		equ *
;----------------------------------------------------------------------

	move.w	w_tmask(work,rnum),@reqdata
	beq.s	@request_done
	move.w	w_counter(work,rnum),@counter	;apply tempo
	add.w	w_tempo(work,rnum),@counter
	addq.w	#1,@counter

	move.w	w_gtempo(work),@gtempo
	clr.w	@seq_step

@sequence_tick
	cmp.w	@gtempo,@counter				;sequence tick
	bcs.s	@tick_done
	sub.w	@gtempo,@counter
	addq.w	#1,@seq_step
	bra.s	@sequence_tick

@tick_done
	move.w	@seq_step,w_seq_step(work,rnum)
	move.w	@counter,w_counter(work,rnum)

@request_done
	addq	#2,rnum
	cmpi.w	#RCOUNT<<1,rnum
	bne		@next_request

;----------------------------------------------------------------------
; update voices
;----------------------------------------------------------------------
mds_update_voices
@updtab		equr	tmpa2
	stop_z80

	lea		w_track(work),twork				; first track's addr
	lea		w_chmask(work),tpos				; channel mask
	move.w	#TCOUNT-1,tnum

@next_voice
	move.w	t_note_flag(twork),flag
	bpl.s	@voice_not_enabled				;skip if not enabled
	swap	flag

	move.b	t_request_id(twork),rnum	;update sequence if needed
	move.w	w_seq_step(work,rnum),d4

;----------------------------------------------------------------------
mds_update_seq_return			equ	*
;----------------------------------------------------------------------

	dbra	d4,mds_update_seq

	movea.l	tpos,tmpa0
	move.b	t_channel_id(twork),chnid		;check priority
	move.b	t_request_id(twork),d0
	rept	RCOUNT-1
		beq.s	@has_priority
		move.w	(tmpa0)+,d1
		btst	chnid,d1
		bne.s	@no_priority
		subq.b	#2,d0						;next request
	endr
@has_priority
	bclr	#nf+nf_silence,flag
	beq.s	@no_silence
	bclr	#nf+nf_enabled,flag
@no_silence
	clr.w	d0
	add.b	chnid,chnid
	move.b	chnid,d0
	add.b	d0,d0
	add.b	chnid,d0
	jmp		@ch_update_table(pc,d0)
@no_priority
	st		t_last_pitch(twork)
	ori.l	#nm_restore<<nf,flag

;----------------------------------------------------------------------
mds_update_return				equ *
;----------------------------------------------------------------------

	swap	flag
	move.w	flag,t_note_flag(twork)
@voice_not_enabled
	lea		TSIZE(twork),twork				; next track
	dbra	tnum,@next_voice

	start_z80

	rts

;======================================================================
; channel update routine table
;----------------------------------------------------------------------
; Each routine must if needed save the flags to memory and jump to
; mds_update_return at the end.
@ch_mapping			macro
	moveq	\1,chnid
	bra.w	\2
	endm

@ch_update_table
	@ch_mapping		#0,mds_fm0_update		;0
	@ch_mapping		#1,mds_fm0_update		;1
	@ch_mapping		#2,mds_fm0_update		;2
	@ch_mapping		#4,mds_fm1_update		;3
	@ch_mapping		#5,mds_fm1_update		;4
	@ch_mapping		#6,mds_fm1_update		;5
	@ch_mapping		#-128,mds_psg_update	;6
	@ch_mapping		#-96,mds_psg_update		;7
	@ch_mapping		#-64,mds_psg_update		;8
	@ch_mapping		#-32,mds_psgn_update	;9
	@ch_mapping		#10,mds_dummy_update	;a
	@ch_mapping		#11,mds_dummy_update	;b
	@ch_mapping		#12,mds_dummy_update	;c
	@ch_mapping		#13,mds_dummy_update	;d
	@ch_mapping		#14,mds_dummy_update	;e
	@ch_mapping		#15,mds_dummy_update	;f

;======================================================================
; starts or stops song playback
;----------------------------------------------------------------------
; INPUT
;   twork - track's working area
;   d0 - request #
; OUTPUT
;   -
; TRASHES
;	d0-d3, tmpa0, tmpa1
mds_handle_request
@reqdata	equr	d0
@tempo		equr	d1						;global tempo
@zero		equr	d1
@tempreg	equr	d2

	bclr	#rf_stop,@reqdata
	bne.w	@stop_song						;stop already playing song

	bclr	#rf_active,@reqdata
	move.w	@reqdata,w_request(work,rnum)	;store request flag

	subq.w	#1,@reqdata						;subtract sound codes
	bmi.w	mds_handle_request_return			;0 to stop a track

	lea		mds_psg_init(pc),tmpa1

	move.w	w_gtempo(work),@tempo
	subq.w	#1,@tempo
	move.w	@tempo,w_tempo(work,rnum)		;initial tempo
	clr.w	@zero
	move.w	@zero,w_counter(work,rnum)
	move.w	@zero,w_seq_step(work,rnum)

	lsl.w	#2,@reqdata						;request table
	move.l	w_sdtop(work),tmpa0				;location of song header
	adda.l	0(tmpa0,@reqdata),tmpa0

	move.l	tmpa0,tbase
	adda.w	(tmpa0)+,tbase					;song base offset
	move.w	(tmpa0)+,w_tmask(work,rnum)		;track mask
	lea		w_track(work),twork
	move.w	#TCOUNT-1,tnum
	move.w	w_tmask(work,rnum),tmask

@next_track
	btst	tnum,tmask
	beq.w	@skip_track

	move.l	tbase,t_base_addr(twork)
	move.b	(tmpa0)+,@reqdata				;channel id
	move.b	#nm_init,t_note_flag(twork)
	move.b	(tmpa0)+,t_channel_flag(twork)
	lsl.w	#8,@reqdata
	or.w	rnum,@reqdata
	move.w	@reqdata,t_channel_id(twork)

	clr.w	@tempreg						;allocate channel
	bset	@reqdata,@tempreg
	or.w	@tempreg,w_chmask(work,rnum)

	cmp.w	#ct_psg<<8,@reqdata
	bcs.s	@not_psg

	move.b	@zero,t_psg_nmode(twork)		;noise mode initialize
	move.l	tmpa1,t_psg_eg_addr(twork)		;psg eg initialize
	move.w	#$000f,t_psg_eg_pos(twork)
	bra.s	@not_fm

@not_psg
	move.b	#$c0,t_fm_pan_lfo(twork)		;initial panning

@not_fm
	st		t_last_pitch(twork)				;previous pitch
	move.w	@zero,t_note(twork)				;note/transpose
	move.w	@zero,t_trs(twork)				;transpose/portamento
	move.w	#$8f00,t_vol(twork)				;vol/lfo_delay

	move.w	@zero,t_peg_addr(twork)			;pitch e.g.
	move.w	@zero,t_peg_mod(twork)			;pitch e.g.
	move.w	(tmpa0)+,t_position(twork)		;start position
	move.w	@zero,t_stack_pos(twork)		;stack_pos & counter
	move.w	#$0b0b,t_rest_time(twork)		;default time (-1)
	move.b	@zero,t_stack_pos(twork)

@skip_track
	lea		TSIZE(twork),twork				;next track
	dbra	tnum,@next_track
	bra.w	mds_handle_request_return

;======================================================================
; stops song playback
;----------------------------------------------------------------------
; INPUT
;   twork - track's working area
; OUTPUT
;   -
; TRASHES
;	d1,d6
@stop_song
	move.w	@reqdata,w_request(work,rnum)	;store request flag
	lea		w_track(work),twork
	move.w	#TCOUNT-1,tnum
	move.w	w_tmask(work,rnum),tmask

@stop_next_track
	btst	tnum,tmask						;track id
	beq.w	@stop_skip_track
	ori.b	#nm_stop,t_note_flag(twork)
	move.b	#RCOUNT<<1,t_request_id(twork)	;track is free

@stop_skip_track
	lea		TSIZE(twork),twork				;next track
	dbra	tnum,@stop_next_track
	clr.w	w_tmask(work,rnum)				;clear trackmask
	clr.w	w_chmask(work,rnum)				;clear chmask
	bra.w	mds_handle_request_return

;======================================================================
; Request track
;----------------------------------------------------------------------
; INPUT
;	a0 - pointer to work area
;	d0 - request track
;	d1 - request priority, range 0-3.
; TRASHES
;	d0,d1
mds_request
	ori.w	#(1<<rf_active)+(1<<rf_stop),d0
	andi.w	#3,d1
	lsl.w	d1
	move.w	d0,w_request(a0,d1)
	rts

;======================================================================
; update track sequences
;----------------------------------------------------------------------
; INPUT
;   twork,rnum - track's working area
; OUTPUT
;   -
; TRASHES
;	?
mds_update_seq
@trackpos	equr	d0
@cmd		equr	d1
@cmdlen		equr	d2
@tempreg	equr	d3
	subq.b	#1,t_counter(twork)
	bcc.w	mds_update_seq_return

;----------------------------------------------------------------------
; command read loop
;----------------------------------------------------------------------
@read_command
	move.l	t_base_addr(twork),tbase
	move.w	t_position(twork),@trackpos
	moveq	#1,@cmdlen

@next_command
	add.w	@cmdlen,@trackpos
	move.b	-1(tbase,@trackpos),@cmd
	bmi.s	@cmd_80

@cmd_rest
	bset	#nf+nf_key_off,flag
	move.b	@cmd,t_rest_time(twork)			;00-7f - rest
	move.b	@cmd,t_counter(twork)
	move.w	@trackpos,t_position(twork)
	bra.w	mds_update_seq_return

@cmd_80
	sub.b	#$81,@cmd						;81 - tie
	beq.s	@cmd_tie
	addq.b	#1,@cmd
	beq.s	@cmd_rest2						;80 - rest (alternate)
	cmp.b	#$60,@cmd
	bcc.s	@cmd_other

	subq.b	#2,@cmd							;82-df - note
	move.b	@cmd,t_note(twork)
	bset	#nf+nf_key_on,flag
	btst	#nf+nf_slur,flag
	bne.s	@cmd_tie
	bset	#nf+nf_key_off,flag
	btst	#cf+cf_drum_mode,flag			;drum mode on?
	bne.s	@cmd_drum_mode

@cmd_tie
	lea		t_note_time(twork),tmpa0
@cmd_read_delta
	move.b	0(tbase,@trackpos),@cmd			;read next command
	bmi		@cmd_previous_delta

@cmd_new_delta
	move.b	@cmd,t_counter(twork)
	move.b	@cmd,(tmpa0)
	addq.w	#1,@trackpos
	move.w	@trackpos,t_position(twork)
	bra.w	mds_update_seq_return

@cmd_previous_delta
	move.b	(tmpa0),t_counter(twork)
	move.w	@trackpos,t_position(twork)
	bra.w	mds_update_seq_return

@cmd_rest2
	bset	#nf+nf_key_off,flag				;80 - rest 2
	move.b	t_rest_time(twork),t_counter(twork)
	move.w	@trackpos,t_position(twork)
	bra.w	mds_update_seq_return

@cmd_other
	andi.w	#$1f,@cmd
	moveq	#0,@cmdlen
	move.b	@cmd_length_table(pc,@cmd),@cmdlen
	lsl.b	#2,@cmd
	pea		@next_command(pc)
	jmp		@cmd_table(pc,@cmd)

@cmd_drum_mode
	andi.w	#$00ff,@cmd
	clr.w	@tempreg
	move.b	t_stack_pos(twork),@tempreg			; push current pos
	move.w	@trackpos,t_stack(twork,@tempreg)
	addq.b	#2,@tempreg
	move.b	@tempreg,t_stack_pos(twork)
	lsl.w	#1,@cmd								; get subroutine pos
	move.w	0(tbase,@cmd),@trackpos
	moveq	#1,@cmdlen
	bra.w	@next_command

;----------------------------------------------------------------------
; command table
;----------------------------------------------------------------------
@cmd_length_table
	dc.b	1,2,2,2, 2,2,2,2, 2,2,2,2, 2,3,2,2		;e0
	dc.b	2,0,0,0, 0,0,3,0, 2,2,1,2, 2,3,1,0		;f0
@cmd_table
	bra.w	@cmd_slr						;e0 slur
	bra.w	@cmd_ins						;e1 instrument
	bra.w	@cmd_vol						;e2 volume
	bra.w	@cmd_volm						;e3 volume change
	bra.w	@cmd_trs						;e4 transpose
	bra.w	@cmd_trsm						;e5 transpose change
	bra.w	@cmd_dtn						;e6 detune
	bra.w	@cmd_pta						;e7 portamento
	bra.w	@cmd_peg						;e8 pitch envelope
	bra.w	@cmd_pan						;e9 panning
	bra.w	@cmd_lfo						;ea lfo sensitivity
	bra.w	@cmd_lfod						;eb lfo delay
	bra.w	@cmd_flg						;ec channel flags
	bra.w	@cmd_fmcreg						;ed fm channel reg write
	bra.w	@cmd_fmtl						;ee fm tl write
	bra.w	@cmd_fmtlm						;ef fm tl change
	bra.w	@cmd_finish						;f0 ** reserved for pcm ins
	bra.w	@cmd_finish						;f1
	bra.w	@cmd_finish						;f2
	bra.w	@cmd_finish						;f3
	bra.w	@cmd_finish						;f4
	bra.w	@cmd_finish						;f5
	bra.w	@cmd_fmreg						;f6 fm register write
	bra.w	@cmd_dmfinish					;f7 drum mode finish
	bra.w	@cmd_comm						;f8 communication byte
	bra.w	@cmd_tempo						;f9 tempo
	bra.w	@cmd_lp							;fa loop
	bra.w	@cmd_lpf						;fb loop finish
	bra.w	@cmd_lpb						;fc loop break
	bra.w	@cmd_lpbl						;fd loop break 2
	bra.w	@cmd_pat						;fe subroutine
@cmd_finish									;ff finish
	clr.w	@cmd
	move.b	t_stack_pos(twork),@cmd
	bne		@cmd_return

	ori.l	#(nm_stop<<nf),flag
	move.b	#RCOUNT<<1,t_request_id(twork)	;track is free

	moveq	#-1,@tempreg					;clear channel mask
	bclr	tnum,@tempreg
	and.w	@tempreg,w_tmask(work,rnum)

	moveq	#-1,@tempreg					;deallocate channel
	move.b	t_channel_id(twork),@cmd
	bclr	@cmd,@tempreg
	and.w	@tempreg,w_chmask(work,rnum)

	addq.w	#4,sp							;break out of command
	move.w	@trackpos,t_position(twork)
	bra.w	mds_update_seq_return

@cmd_return
	subq.b	#2,@cmd
	move.b	@cmd,t_stack_pos(twork)
	move.w	t_stack(twork,@cmd),@trackpos	; pop return address
@cmd_dummy
	rts

;----------------------------------------------------------------------
; slr - set note slur
;----------------------------------------------------------------------
@cmd_slr
	bset	#nf+nf_slur,flag
	rts

;----------------------------------------------------------------------
; ins - set instrument (or PSG envelope)
;----------------------------------------------------------------------
; CAUTION: instrument data must fit within 32k of w_sdtop address
;  due to the "movea @cmd,tmpa0"
;----------------------------------------------------------------------
@cmd_ins
	move.b	0(tbase,@trackpos),@cmd
	move.b	@cmd,t_ins(twork)
	bset	#nf+nf_ins,flag
	lsl.w	@cmd
	movea.w	0(tbase,@cmd),tmpa0				; instr address
	move.b	t_channel_id(twork),@cmd
	cmpi.b	#6,@cmd							; fm or psg
	bcc.s	@cmd_ins_psg
	adda.l	w_sdtop(work),tmpa0				; ptr. to ins data
	bset	#nf+nf_key_off,flag
	move.l	24(tmpa0),t_fm_tl(twork)
	move.b	28(tmpa0),t_fm_alg(twork)
	move.b	29(tmpa0),t_ins_trs(twork)
	rts

@cmd_ins_psg
	move.w	tmpa0,t_psg_eg_addr(twork)
	move.w	#$000f,t_psg_eg_pos(twork)
	rts

;----------------------------------------------------------------------
; vol - set volume
;----------------------------------------------------------------------
@cmd_vol
	move.b	0(tbase,@trackpos),t_vol(twork)
	bset	#nf+nf_vol,flag
	rts
@cmd_volm
	move.b	0(tbase,@trackpos),@cmd
	add.b	@cmd,t_vol(twork)
	bset	#nf+nf_vol,flag
	rts

;----------------------------------------------------------------------
; vol - set transpose
;----------------------------------------------------------------------
@cmd_trs
	move.b	0(tbase,@trackpos),t_trs(twork)
	rts
@cmd_trsm
	move.b	0(tbase,@trackpos),@cmd
	add.b	@cmd,t_trs(twork)
	rts

;----------------------------------------------------------------------
; dtn - set detune
;----------------------------------------------------------------------
@cmd_dtn
	move.b	0(tbase,@trackpos),t_dtn(twork)
	rts

;----------------------------------------------------------------------
; pta - set portamento
;----------------------------------------------------------------------
@cmd_pta
	move.b	0(tbase,@trackpos),t_pta(twork)
	rts

;----------------------------------------------------------------------
; peg - set pitch envelope
;----------------------------------------------------------------------
@cmd_peg
	clr.w	@cmd
	move.w	@cmd,t_peg_mod(twork)
	move.w	@cmd,t_peg_delay(twork)					;also clears pos
	move.b	0(tbase,@trackpos),@cmd
	beq.s	@cmd_peg_off
	lsl.w	#1,@cmd
	move.w	0(tbase,@cmd),t_peg_addr(twork)
	rts
@cmd_peg_off
	move.w	@cmd,t_peg_addr(twork)
	rts

;----------------------------------------------------------------------
; pan - set panning
;----------------------------------------------------------------------
; bit 6 = enable left speaker
; bit 7 = enable right speaker
;----------------------------------------------------------------------
@cmd_pan
	move.b	t_fm_pan_lfo(twork),@cmd
	andi.b	#$3f,@cmd
	or.b	0(tbase,@trackpos),@cmd
	move.b	@cmd,t_fm_pan_lfo(twork)
	bset	#nf+nf_pan_lfo,flag
	rts

;----------------------------------------------------------------------
; lfo - set lfo depth (channel specific setting)
;----------------------------------------------------------------------
; bit 0-1 = FM sensitivity
; bit 3-5 = AM sensitivity
;----------------------------------------------------------------------
@cmd_lfo
	move.b	t_channel_id(twork),@cmd
	cmpi.b	#6,@cmd							; fm or psg
	bcc.s	@cmd_nmode

	move.b	t_fm_pan_lfo(twork),@cmd
	andi.b	#$c0,@cmd
	or.b	0(tbase,@trackpos),@cmd
	move.b	@cmd,t_fm_pan_lfo(twork)
	bset	#nf+nf_pan_lfo,flag
	rts

;----------------------------------------------------------------------
; nmode - set noise mode
;----------------------------------------------------------------------
; 00 - use key code
; e3 - periodic noise, psg3 control
; e7 - white noise, psg3 control
;----------------------------------------------------------------------
@cmd_nmode
	st		t_last_pitch(twork)
	move.b	0(tbase,@trackpos),@cmd
	move.b	@cmd,t_psg_nmode(twork)
	rts

;----------------------------------------------------------------------
; lfod - set lfo delay
;----------------------------------------------------------------------
@cmd_lfod
	move.b	0(tbase,@trackpos),t_lfo_delay(twork)
	rts

;----------------------------------------------------------------------
; flg - set channel flags
;----------------------------------------------------------------------
; 00-07 - clear flag
; 08-0F - set flag
; 80-8F - ch3 mask set
;----------------------------------------------------------------------
@cmd_flg
	st		t_last_pitch(twork)				; force pitch update
	clr.w	@cmd
	move.b	0(tbase,@trackpos),@cmd
	bmi.s	@cmd_flg_fm3					; bit7 set = fm3 flags
	bclr	#3,@cmd							; bit3 set = set a flag
	beq.s	@cmd_flg_off
	addi.b	#cf,@cmd
	bset	@cmd,flag
	rts
@cmd_flg_off
	addi.b	#cf,@cmd
	bclr	@cmd,flag
	rts
@cmd_flg_fm3
	beq.s	@cmd_flg_fm3_off
	bset	#cf+cf_fm3_enable,flag
	move.b	@cmd,t_fm3_mask(twork)	; we're reusing MSB of t_base_addr
	rts
@cmd_flg_fm3_off
	bclr	#cf+cf_fm3_enable,flag
	rts

;----------------------------------------------------------------------
; fmreg - write to FM chip
;----------------------------------------------------------------------
@cmd_fmreg
	rts
@cmd_fmcreg
	rts

;----------------------------------------------------------------------
; fmtl - set FM TL
;----------------------------------------------------------------------
@cmd_fmtl
	rts
@cmd_fmtlm
	rts

;----------------------------------------------------------------------
; comm - communication byte
;----------------------------------------------------------------------
@cmd_comm
	rts

;----------------------------------------------------------------------
; tempo - set song tempo
;----------------------------------------------------------------------
@cmd_tempo
	clr.w	@cmd
	move.b	0(tbase,@trackpos),@cmd
	move.w	@cmd,w_tempo(work,rnum)
	rts

;----------------------------------------------------------------------
; lp - loop start
;----------------------------------------------------------------------
@cmd_lp
	clr.w	@cmd
	move.b	t_stack_pos(twork),@cmd
	move.b	#$ff,t_stack(twork,@cmd)
	move.w	@trackpos,2+t_stack(twork,@cmd)
	addq.b	#4,@cmd
@cmd_lpf_exit
	move.b	@cmd,t_stack_pos(twork)
	rts

;----------------------------------------------------------------------
; lpf - loop finish
;----------------------------------------------------------------------
@cmd_lpf
	clr.w	@cmd
	move.b	t_stack_pos(twork),@cmd
	subq.b	#4,@cmd
	move.b	t_stack(twork,@cmd),@tempreg
	cmpi.b	#$ff,@tempreg
	bne.s	@cmd_lpf_decrease
	move.b	0(tbase,@trackpos),@tempreg
@cmd_lpf_decrease
	subq.b	#1,@tempreg
	beq.s	@cmd_lpf_exit
	move.b	@tempreg,t_stack(twork,@cmd)
	move.w	2+t_stack(twork,@cmd),@trackpos
	moveq	#1,@cmdlen
	rts

;----------------------------------------------------------------------
; lpb - loop break
;----------------------------------------------------------------------
@cmd_lpb
	clr.w	@cmd
	move.b	t_stack_pos(twork),@cmd
	subq.b	#4,@cmd  ;optimize with stack-4?
	cmpi.b	#1,t_stack(twork,@cmd)
	bne.s	@cmd_lpb_skip
	move.b	0(tbase,@trackpos),@cmdlen
	move.b	@cmd,t_stack_pos(twork)
@cmd_lpb_skip
	rts

;----------------------------------------------------------------------
; lpbl - loop break (long)
;----------------------------------------------------------------------
@cmd_lpbl
	clr.w	@cmd
	move.b	t_stack_pos(twork),@cmd
	subq.b	#4,@cmd
	tst.b	t_stack(twork,@cmd)
	bne.s	@cmd_lpb_skip
	move.b	0(tbase,@trackpos),@tempreg ;no need to align 16-bit
	lsl.w	#8,@tempreg
	move.b	1(tbase,@trackpos),@tempreg
	move.w	@tempreg,@cmdlen
	move.b	@cmd,t_stack_pos(twork)
	rts

;----------------------------------------------------------------------
; pat - subroutine
;----------------------------------------------------------------------
@cmd_pat
	clr.w	@cmd
	move.b	t_stack_pos(twork),@cmd				; push current pos
	addq.w	#2,@trackpos
	move.w	@trackpos,t_stack(twork,@cmd)
	addq.b	#2,@cmd
	move.b	@cmd,t_stack_pos(twork)
	clr.w	@cmd
	move.b	-2(tbase,@trackpos),@cmd			; get subroutine pos
	lsl.w	#1,@cmd
	move.w	0(tbase,@cmd),@trackpos
	rts

;----------------------------------------------------------------------
; dmfinish - drum mode finish byte
;----------------------------------------------------------------------
@cmd_dmfinish
	clr.w	@cmd
	move.b	0(tbase,@trackpos),t_note(twork)
	move.b	t_stack_pos(twork),@cmd
	subq.b	#2,@cmd
	move.b	@cmd,t_stack_pos(twork)
	move.w	t_stack(twork,@cmd),@trackpos		; pop return address
	addq.w	#4,sp								;break out of command
	bra.w	@cmd_tie

;======================================================================
; check channel priority
;----------------------------------------------------------------------
; INPUT
;   d0 - channel id
; OUTPUT
;   d0 - request # with highest priority
; TRASHES
;	tmpa0, d1, d2
mds_check_priority
	move.w	d0,d2
	clr.w	d0
	lea		w_chmask(work),tmpa0
	rept	RCOUNT
		move.w	(tmpa0)+,d1
		btst	d2,d1
		bne		@end
		addq.b	#2,d0						;next request
	endr
@end
	rts

;======================================================================
; get FM pitch
;----------------------------------------------------------------------
; INPUT
;   d0 - key code + fraction
; OUTPUT
;   d0 - pitch value
; TRASHES
;   tmpa1, d1, d2
mds_get_fm_pitch
	lsl.l	#8,d0
	move.w	d0,d1							; upper bits of keycode
	swap	d0
	lea		mds_note_table(pc),tmpa1
	move.b	mds_octave_table-mds_note_table(tmpa1,d0),d2	; octave
	move.b	0(tmpa1,d0),d0
	add.b	t_ins_trs(twork),d0				;freq tab displacement
	lea		@fm_freq_tab(pc,d0),tmpa1
	move.w	2(tmpa1),d0
	sub.w	(tmpa1),d0
	mulu	d1,d0							;interpolate
	swap	d0
	add.w	(tmpa1),d0
	rol.w	#8,d0
	add.b	d2,d0							;octave added
	rts
@fm_freq_tab
	dc.w 161,171,181,191,203,215,228,241,255,271,287,304		; 0-11
	dc.w 322,341,361,383,406,430,455,482,511,541,574,608		; 12-23
	dc.w 644,682,723,766,811,859,910,965,1022,1083,1147,1215	; 24-35
	dc.w 1288,1364,1445,1531,1622,1719,1821,1929,2044			; 36-45

;======================================================================
; get PSG pitch
;----------------------------------------------------------------------
; INPUT
;   d0 - key code + fraction
; OUTPUT
;   d0 - pitch value
; TRASHES
;   tmpa0, d1, d2
mds_get_psg_pitch
	lsl.l	#8,d0
	move.w	d0,d1							; upper bits of keycode
	swap	d0
	lea		mds_note_table(pc),tmpa0
	move.b	mds_octave_table-mds_note_table(tmpa0,d0),d2	; octave
	move.b	0(tmpa0,d0),d0
	lea		@psg_freq_tab(pc,d0),tmpa0
	move.w	2(tmpa0),d0
	sub.w	(tmpa0),d0
	ext.w	d1
	mulu	d1,d0							;interpolate
	swap	d0
	add.w	(tmpa0),d0
	lsr.b	#3,d2
	lsr.w	d2,d0							;octave shifted
	rts
@psg_freq_tab
	dc.w	851,803,758,715,675,637,601,568,536,506,477,450,425

;======================================================================
; Note/octave division table
;----------------------------------------------------------------------
; note values are multiplied by 2 since they are likely going to be
; used as LUT indices
; Also the note table should come before the octave table, as the
; entries in the octave_table protect against odd memory address
; accesses.
mds_note_table
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22 ;0
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22 ;12
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22 ;24
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22 ;36
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22 ;48
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22 ;60
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22 ;72
	dc.b	 0, 2, 4, 6, 8,10,12,14,16,18,20,22 ;84
mds_octave_table
	dcb.b   12,0  ;0  =0
	dcb.b	12,8  ;12 =1
	dcb.b	12,16 ;24 =2
	dcb.b	12,24 ;36 =3
	dcb.b	12,32 ;48 =4
	dcb.b	12,40 ;60 =5
	dcb.b	12,48 ;72 =6
	dcb.b	12,56 ;84 =7
; adding more octaves for PSG octave shift. It shouldn't matter that
; the note_table is overflowing into octave_table at these octaves.
	dcb.b	12,64 ;96 =8
	dcb.b	12,72 ;108=9
	dcb.b	12,80 ;120=10
; these bytes are just to pad the note_table, but it can be repurposed
; as long as the data just contains even 8-bit numbers
	dcb.b	256-(96+132),88

;======================================================================
; PSG envelope initialize
;----------------------------------------------------------------------
mds_psg_init
	dc.b	$10,$01,$1f,$00

;======================================================================
; dummy routine
;----------------------------------------------------------------------
mds_ch_dummy
	rts

;======================================================================
; Pitch update
;----------------------------------------------------------------------
; INPUT
;  work, twork
; OUTPUT
;  d0 - calculated pitch
; TRASHES
;  tmpa1,d1,d2,d3,d4
mds_pitch_update
	moveq	#0,d0
	move.b	t_note(twork),d1
	add.b	t_trs(twork),d1
	lsl.w	#8,d1
	move.b	t_dtn(twork),d0							; signed value
	ext.w	d0
	add.w	d1,d0									; d0=porta_target

;----------------------------------------------------------------------
; portamento update
;----------------------------------------------------------------------
	clr.w	d3
	move.b	t_pta(twork),d3
	beq.s	@porta_done

	move.w	d0,d2
	sub.w	t_pitch(twork),d2						;d2=porta_delta
	beq.s	@porta_done

	move.w	d2,d1									;get step
	asr.w	#8,d1
	bpl.s	@add_step
	subq.w	#2,d1
@add_step
	addq.w	#1,d1

	muls	d3,d1
	add.w	t_pitch(twork),d1						;d1=new_pitch

	move.w	d0,d3
	sub.w	d1,d3
	eor.w	d2,d3
	bmi.s	@porta_done
	move.w	d1,d0
@porta_done
	move.w	d0,t_pitch(twork)

;----------------------------------------------------------------------
; pitch envelope update
;----------------------------------------------------------------------
	move.w	t_peg_addr(twork),d1
	beq.s	@no_peg

	btst	#nf+nf_key_on,flag
	beq.s	@no_retrig
	clr.w	t_peg_delay(twork)
@no_retrig

	movea.w	d1,tmpa1
	adda.l	w_sdtop(work),tmpa1

	clr.w	d1
	move.b	t_peg_pos(twork),d1
	lsl.w	#2,d1
	move.w	t_peg_mod(twork),d2						;d2=modulator

	move.b	t_peg_delay(twork),d3
	bne.s	@no_reset
	move.w	0(tmpa1,d1),d2							;d2=init modulator

@no_reset
	move.b	2(tmpa1,d1),d4
	ext.w	d4
	add.w	d2,d4									;add delta
	move.w	d4,t_peg_mod(twork)
	add.w	d4,d0

	cmp.b	3(tmpa1,d1),d3							;delay done?
	bne.s	@delay_not_done

	move.w	4(tmpa1,d1),d2							;next command
	subi.w	#$7f00,d2
	blt.s	@no_jump

	move.w	d2,t_peg_delay(twork)					;jump to position
@no_peg
	rts

@no_jump
	lsr.w	#2,d1
	addq.b	#1,d1
	move.w	d1,t_peg_delay(twork)					;next position
	rts

@delay_not_done
	addq.b	#1,d3									;increase delay
	beq.s	@no_peg									; ff = endless
	move.b	d3,t_peg_delay(twork)
	rts

;======================================================================
; FM patch upload
;----------------------------------------------------------------------
; NOTE: does not wait for the FM busy flag to clear at the beginning
;       of this routine
; INPUT:
;  tmpa0 - FM write address
;  tmpa1 - instrument data address
;  chnid - FM logical channel #
; TRASHES
;  tmpa1,d0,d1,d2,d3
mds_fm_update_ins
@fm			equr	tmpa0
	move.w	chnid,d1
	andi.b	#$03,d1
	swap	chnid

;----------------------------------------------------------------------
; channel mute
;----------------------------------------------------------------------
; optimization: rather than checking the busy flag we could just wait
; the mandated number of cycles between writes = 83 according to YM2608
; manual
	move.b	#$40,d0								;tl=max
	add.b	d1,d0
	moveq	#3,d2								;op count
	bra.s	@notbusy
@nextop											; burn 83-14 = 69
	bsr.s	@burn56								;     56 : 56
@notbusy:
	move.b	d0,0(@fm,chnid)						;     14 : 70
	move.b	#$7f,1(@fm,chnid)					;        : 18
	addq.b	#4,d0								;  10/14 : 18 (14)
	dbra	d2,@nextop							;  10/14 : 32

;----------------------------------------------------------------------
; load inst data
;----------------------------------------------------------------------
	lea		@op_reg_table(pc),tmpa2				;      8
	moveq	#5,d3								;      4

@nextreg
	move.b	(tmpa2)+,d0							;      8
	add.b	d1,d0								;      4
	moveq	#3,d2								;      4
@nextop2										; burn 83-14 = 69
	bsr.s	@burn56								;     56 : 56
	move.b	d0,0(@fm,chnid)						;     14 : 70
	move.b	(tmpa1)+,1(@fm,chnid)				;       : 18
	addq.b	#4,d0								;      4 :  4
	dbra	d2,@nextop2							;  10/14 : 18 (14)
	dbra	d3,@nextreg							;  10/14 : 32

;----------------------------------------------------------------------
; load feedback/algorithm
;----------------------------------------------------------------------
												; burn 83-32 = 51
	addq.w	#4,tmpa1							;      8 :  8
	move.b	#$b0,d0								;      8 : 16
	add.b	d1,d0								;      4 : 20
	cmp.b	sound_fm_a0,d0						;12+4=16 : 36
	move.b	d0,0(@fm,chnid)						;     14 : 52
	move.b	(tmpa1)+,1(@fm,chnid)				;        : 18
	swap	chnid
	rts

;----------------------------------------------------------------------
; burn cycles while FM chip is busy
;----------------------------------------------------------------------
@burn56											; bsr=18 : 18
	cmp.b	*(pc,d0),d0							;10+4=14 : 32
	nop											;      4 : 36
	nop											;      4 : 40
	rts											;     16 : 56

;----------------------------------------------------------------------
; operator register table
;----------------------------------------------------------------------
@op_reg_table
	dc.b	$30,$50,$60,$70,$80,$90

;======================================================================
; FM volume update
;----------------------------------------------------------------------
; NOTE: does not wait for the FM busy flag to clear at the beginning
;       of this routine
; INPUT:
;  tmpa0 - FM write address
;  chnid - FM logical channel #
; TRASHES
;  tmpa1,tmpa2,d0,d1,d2,d3,d4
mds_fm_update_vol
@fm			equr	tmpa0
	lea		4+t_fm_tl(twork),tmpa1
	move.b	t_vol(twork),d3
	bpl.s	@no_vol_table
	cmpi.b	#$90,d3
	bcc.s	@no_vol_table
	andi.w	#$000f,d3
	move.b	mds_fm_vol_table(pc,d3),d3

@no_vol_table
	move.b	t_fm_alg(twork),d4
	andi.w	#$0007,d4

	moveq	#3,d2
	move.w	chnid,d1
	and.b	d2,d1
	add.b	#$4c,d1
	swap	chnid
@nextop											; burn 83-14 = 69
	move.b	-(tmpa1),d0							;      10 : 10
	cmp.b	mds_fm_op_table(pc,d4),d2			; 10+4=14 : 24
	bcs.s	@modulator							;    10/8 : 32
	add.b	d3,d0								;       4 : 36
	bpl.b	@no_overflow						;    10/8 : 44
	move.b	#$7f,d0								;       8 : 52
	bra.s	@write_vol							;      10 : 62
@modulator										;           34
	cmp.b	*(pc),d0							;  8+4=12 : 46
@no_overflow									;           46
	cmp.b	*(pc),d0							;  8+4=12 : 58
@write_vol										;           58 to 62
	move.b	d1,0(@fm,chnid)						;      14 : 72-76
	nop											;       4 :  4
	move.b	d0,1(@fm,chnid)						;      14 : 18
	subq.b	#4,d1								;       4 :  4
	dbra	d2,@nextop							;   10/14 : 18 (14)
	swap	chnid
	rts

;======================================================================
; FM volume calculation tables
;----------------------------------------------------------------------
mds_fm_op_table
	dc.b	3,3,3,3,2,1,1,0
mds_fm_vol_table
	dc.b	42,40,37,34,32,29,26,24,21,18,16,13,10,8,5,2

;======================================================================
; FM update
;----------------------------------------------------------------------
; INPUT:
;  work, twork, chnid
; TRASHES:
;  chnid
mds_fm1_update
	bset	#17,chnid								; use second port
mds_fm0_update
@fm			equr	tmpa0
	lea		sound_fm_a0,@fm
;----------------------------------------------------------------------
; key_off update
;----------------------------------------------------------------------
	bclr	#nf+nf_key_off,flag
	beq.s	@no_key_off
;TODO: FM3, pcm

@busy0
	btst.b	#7,(@fm)
	bne.s	@busy0
	move.b	#$28,(@fm)
	nop
	nop
	move.b	chnid,1(@fm)						;12 cycles + 2 nop

@no_key_off
;----------------------------------------------------------------------
; instrument update
;----------------------------------------------------------------------
; this code should burn enough cycles (92) to make it necessary not to
; wait for busy flag in mds_fm_upload.
	bclr	#nf+nf_ins,flag
	beq.s	@no_ins

	move.b	t_ins(twork),d0
	lsl.w	d0
	move.l	t_base_addr(twork),tmpa1
	movea.w	0(tmpa1,d0),tmpa1
	adda.l	w_sdtop(work),tmpa1					; ptr. to ins data
	bsr.w	mds_fm_update_ins
	bclr	#nf+nf_vol,flag
	bra.s	@update_vol

@no_ins
;----------------------------------------------------------------------
; vol update
;----------------------------------------------------------------------
	bclr	#nf+nf_vol,flag
	beq.s	@no_vol

@update_vol
	bsr.w	mds_fm_update_vol

@no_vol
;----------------------------------------------------------------------
; pitch update
;----------------------------------------------------------------------
	bsr.w	mds_pitch_update
	cmp.w	t_last_pitch(twork),d0
	beq.s	@no_write_pitch

	move.w	d0,d3
	bsr.w	mds_get_fm_pitch
	move.b	chnid,d1
	swap	chnid
	andi.b	#3,d1
	addi.b	#$a4,d1
	move.b	d1,0(@fm,chnid)
	nop
	move.b	d0,1(@fm,chnid)						; 4+14 : 18
	ror.w	#8,d0								; 22  :  22
	subq.b	#4,d1								;  4  :  28
	move.w	d3,t_last_pitch(twork)				; 12  :  40
	move.b	d1,0(@fm,chnid)						; 14  :  54
	nop
	move.b	d0,1(@fm,chnid)						; 4+14 : 18
	swap	chnid

@no_write_pitch
;----------------------------------------------------------------------
; pan_lfo update
;----------------------------------------------------------------------
	bclr	#nf+nf_pan_lfo,flag
	beq.s	@no_lfo
	move.b	t_fm_pan_lfo(twork),d0
	move.b	chnid,d1
	swap	chnid
	andi.b	#3,d1
	addi.b	#$b4,d1
	move.b	d1,0(@fm,chnid)
	nop
	move.b	d0,1(@fm,chnid)						; 4+14 : 18
	swap	chnid

@no_lfo
;----------------------------------------------------------------------
; key_on update
;----------------------------------------------------------------------
	bclr	#nf+nf_key_on,flag
	beq.s	@no_key_on

	btst	#cf+cf_fm3_enable,flag
	beq.s	@no_fm3_key_on						; TODO: fm3_keyon

	bra.w	mds_update_return

@no_fm3_key_on
;	btst	#cf+cf_pcm_control,flag				; TODO: pcm_keyon

	bclr	#nf+nf_slur,flag
	bne.s	@no_key_on

	move.b	#$28,(@fm)
	move.b	chnid,d0							; 4 :  4
	ori.b	#$f0,d0								; 8 : 12
	move.b	d0,1(@fm)							;12 : 24

@no_key_on

	bra.w	mds_update_return

;======================================================================
; PSG envelope update
;----------------------------------------------------------------------
mds_psg_update_env
@pos	equr	d1
@cmd	equr	d0

	tst.l	flag								; enable flag cleared?
	bpl.w	@silence

;----------------------------------------------------------------------
; key on
;----------------------------------------------------------------------
	btst	#nf+nf_key_on,flag
	beq.s	@no_keyon

	move.l	#(1<<(nf+nf_slur))+(1<<(cf+cf_fm3_enable)),@cmd
	and.l	flag,@cmd
	bne.s	@no_keyon

	moveq	#$1f,@cmd								;silence
	move.w	@cmd,t_psg_eg_pos(twork)
	andi.l	#~((1<<(nf+nf_key_on))+(1<<(nf+nf_key_off))),flag

	st		t_last_pitch(twork)	; Always rewrite pitch after PSG keyon
	bra.s	@command

@no_keyon
;----------------------------------------------------------------------
; envelope disable
;----------------------------------------------------------------------
	btst	#nf+nf_key_off,flag					;skip delays for keyoff
	bne.s	@command
	move.b	t_psg_eg_delay(twork),@cmd
	beq.s	@hold

;----------------------------------------------------------------------
; envelope delay
;----------------------------------------------------------------------
	cmpi.b	#$20,@cmd
	bcs.s	@command

	subi.b	#$10,@cmd
	move.b	@cmd,t_psg_eg_delay(twork)
@hold
	bclr	#nf+nf_vol,flag
	bne.s	@write_vol
	rts

@command
;----------------------------------------------------------------------
; read command
;----------------------------------------------------------------------
	clr.w	@pos
	move.b	t_psg_eg_pos(twork),@pos
	move.w	t_psg_eg_addr(twork),tmpa1
	adda.l	w_sdtop(work),tmpa1
	move.b	0(tmpa1,@pos),@cmd
	addq.b	#1,@pos

;----------------------------------------------------------------------
; sustain command
;----------------------------------------------------------------------
	bclr	#nf+nf_key_off,flag
	beq.s	@no_release
	cmpi.b	#$01,@cmd
	bne.s	@no_jump							; key off can't jump
	bra.s	@read_next

@no_release
	cmpi.b	#$01,@cmd
	bne.s	@no_sustain							; sustain hold
	clr.b	t_psg_eg_delay(twork)
	bra.s	@hold

@no_sustain
;----------------------------------------------------------------------
; jump command
;----------------------------------------------------------------------
	cmpi.b	#$02,@cmd
	bne.s	@no_jump
	move.b	0(tmpa1,@pos),@pos

@read_next
	move.b	0(tmpa1,@pos),@cmd
	addq.b	#1,@pos

@no_jump
;----------------------------------------------------------------------
; volume + length command
;----------------------------------------------------------------------
	cmpi.b	#$10,@cmd
	bcc.b	@no_silence
@silence
	clr.b	t_psg_eg_delay(twork)		; disable envelope for now
	bclr	#nf+nf_key_off,flag
	moveq	#$1f,@cmd
	or.b	chnid,@cmd
	move.b	@cmd,sound_psg
	rts

@no_silence
	lsl.w	#8,@pos
	move.b	@cmd,@pos
	move.w	@pos,t_psg_eg_pos(twork)	; write both at the same time

;----------------------------------------------------------------------
; It's very likely that this must be rewritten once global volume and
; fadeout is supported, and the FM->PSG volume conversion could be done
; at that point.
;----------------------------------------------------------------------
@tvol	equr	d1
@evol	equr	d0

@write_vol
	moveq	#15,d2
	move.b	t_vol(twork),@tvol
	not.b	@tvol
	and.b	d2,@tvol
	and.b	d2,@evol
	add.b	@evol,@tvol
	cmp.b	d2,@tvol
	bcs.s	@no_clamp
	move.b	d2,@tvol
@no_clamp
	ori.b	#$10,@tvol
	or.b	chnid,@tvol
	move.b	@tvol,sound_psg
	rts

;======================================================================
; PSG update
;----------------------------------------------------------------------
mds_psg_update
	bsr.w	mds_psg_update_env
	bsr.w	mds_pitch_update
	cmp.w	t_last_pitch(twork),d0
	beq.w	mds_update_return
	move.w	d0,t_last_pitch(twork)
mds_psg_set_pitch
	bsr.w	mds_get_psg_pitch
	move.b	d0,d1
	andi.b	#$0f,d1
	or.b	chnid,d1
	move.b	d1,sound_psg
	lsr.w	#4,d0
	move.b	d0,sound_psg
	bra.w	mds_update_return

;======================================================================
; PSG noise update
;----------------------------------------------------------------------
mds_psgn_update
	bsr.w	mds_psg_update_env
	bsr.w	mds_pitch_update
	cmp.w	t_last_pitch(twork),d0
	beq.w	mds_update_return
	move.w	d0,t_last_pitch(twork)
	move.b	t_psg_nmode(twork),d1
	beq.s	@no_psg3_control

	move.b	d1,sound_psg						; set noise mode
	move.b	#$c0,chnid							; set psg3 chnid
	bra.s	mds_psg_set_pitch

@no_psg3_control
	ror.w	#8,d0
	andi.b	#$07,d0
	ori.b	#$e0,d0
	move.b	d0,sound_psg
	bra.w	mds_update_return

;======================================================================
; Dummy channel update (only check for FM3)
;----------------------------------------------------------------------
mds_dummy_update
	bra.w	mds_update_return

;======================================================================
; Z80 driver
;----------------------------------------------------------------------
mds_z80_driver
	incbin	"mdssub.bin"
mds_z80_driver_size		equ *-mds_z80_driver
	even

; vim: set ft=asm68k sw=4 ts=4 noet:
