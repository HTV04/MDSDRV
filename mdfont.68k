	if def(VWF_ENABLED)

;======================================================================
; Creates a bitmap for vwf routine
;----------------------------------------------------------------------
; INPUT
;	d0 = Bitmap address
;		H64 = (row << 6) | column
;		H32 = (row << 5) | column
;	d1 = bit15-8, Character flags, bit7-0, write count
;	d2 = Tilemap address
;		H64 = (row << 6) | column
;		H32 = (row << 5) | column
; TRASHES
;	d0-d1
vdp_bitmap:
	setup_vram_write	d2
	lsr.w	#5,d0
@loop
	move.w	d1,d2
	and.w	#$7ff,d2
	or.w	d0,d2
	addq.b	#1,d0
	move.w	d0, vdp_data
	subq.b	#1,d1
	bne.s	@loop
	rts

;======================================================================
; Set vwf bitmap
;----------------------------------------------------------------------
; INPUT
;   a0 = text pointer
;	d0 = Tilemap VRAM address
;		H64 = (row << 6) | column
;		H32 = (row << 5) | column
;	d1 = bit15-8, Character flags, bit7-0, write count
;	d2 = Bitmap address
; OUTPUT
;   a0 = End of the string
; TRASHES
;	a0, d0-d1
vwf_bitmap:
	setup_vram_write	d0
	lsr.w	#5,d2
@loop
	move.w	d1,d0
	and.w	#$7ff,d0
	or.w	d2,d0
	addq.b	#1,d1
	move.w	d0, vdp_data
	subq.b	#1,d1
	bne.s	@loop
	rts

;======================================================================
; Prints text using a variable width font
;----------------------------------------------------------------------
; INPUT
;	a0 = text pointer
;	a1 = font character data pointer
;	a2 = font character width pointer
;   d0 = VRAM address
;	d4 = pixel offset  (vwf_1row_offset only)
; OUTPUT
;	a0 = End of the string
vwf_print_offset:
	movem.l	d0-d7/a1/a3-a5,-(sp)	; backup regs
	bra.s	vwf_start
vwf_print:
	movem.l	d0-d7/a1/a3-a5,-(sp)	; backup regs
	clr.l	d4
vwf_start:
	vdp_address d0
	ori.l	#vram_write_flag, d0
	move.l	d0,a4				; backup address

	move.w	#7,d7
	move.l	a0,a3
	bra.b	@start_line
@next_line
	move.l	a3,a0
	addq.l	#4,a1				; next line in the font data
@start_line
	clr.l	d2					; d2 = char width
	clr.l	d4					; d4 = pixel offset
	clr.l	d5					; d5 = pixel buffer
	clr.l	d6					; d6 = character buffer

	move.l	a4,a5
	adda.l	#$00040000,a4		; next line (4 bytes)

@print_loop
	move.l	a5,vdp_control		; write address
	adda.l	#$00200000,a5		; next tile (32 bytes)

	bsr.w	vwf_line
	tst.b	(a0)
	bne.s	@print_loop

	bsr.w	vwf_line_finish		; draw the last part of the character if needed
	dbra	d7, @next_line

	movem.l	(sp)+,d0-d7/a1/a3-a5
	rts

vwf_line:
	cmpi.b	#7,d4			; more than 8 bytes remaining (leftover character)
	bcs.s	@pixel_loop

	subi.b	#8,d4

	sub.l	d4,d2			; shift offset in character
	lsl.l	#2,d2

	lsl.l	d2,d6			; remaining pixels
	move.l	d6,d5			; move to pixel buffer

@pixel_loop
	clr.l	d0
	move.b	(a0), d0		; is next character zero?
	beq.s	@break

	addq.l	#1,a0

	clr.l	d2				; character width
	move.b	0(a2,d0),d2
	lsl.l	#5,d0			; character buffer
	move.l	0(a1,d0.w),d6

	move.l	d4,d3			; pixel offset
	lsl.l	#2,d3

	rol.l	d3,d5			; rotate pixel buffer

	move.l	d2,d0			; char size mask
	lsl.l	#2,d0

	add.l	d2,d4			; add character width to pixel offset

	move.l	@blit_mask(pc,d0), d0
	or.l	@overflow_mask(pc,d3), d0 ; (OR instead of AND+NOT, note masks are inverted)
	and.l	d0,d5			; make space for character

	not.l	d0
	and.l	d6,d0			; character data
	or.l	d0,d5			; blit to pixel buffer
	
	ror.l	d3,d5			; rotate pixel buffer

	cmpi.b	#8,d4
	bcs.s	@pixel_loop
@break
	move.l	d5,vdp_data		; write tile
	rts

@blit_mask:
	dc.l	~$00000000,~$f0000000,~$ff000000,~$fff00000
	dc.l	~$ffff0000,~$fffff000,~$ffffff00,~$fffffff0,~$ffffffff

@overflow_mask:  ;table to prevent masking out of bounds
	dc.l	~$ffffffff,~$fffffff0,~$ffffff00,~$fffff000
	dc.l	~$ffff0000,~$fff00000,~$ff000000,~$f0000000

vwf_line_finish:
	cmpi.b	#7,d4			; more than 8 bytes remaining (leftover character)
	bcs.s	@break

	subi.b	#8,d4

	sub.l	d4,d2			; shift offset in character
	lsl.l	#2,d2

	lsl.l	d2,d6			; remaining pixels
	move.l	d6,d5			; move to pixel buffer

	move.l	a5,vdp_control	; write address
	move.l	d5,vdp_data		; write tile
@break
	rts
	
	endif ; VWF_ENABLED
; vim: set ft=asm68k sw=4 ts=4 noet: