;======================================================================
; MDSDRV - mega drive 68k sound driver
; (C) 2019-2020 ian karlsson
;----------------------------------------------------------------------
; Z80 driver - handles PCM and common FM chip writes
;======================================================================

;======================================================================
; PCM driver, attempt 2
;
; It seems like the max sample rate for this driver is about 16000? hz.
; around 14-15000? with mixing.
; Unfortunately just polling the FM timer creates a lot of overhead.
; By removing the timer polls, it's possible to go up to >20 khz.
;======================================================================

;======================================================================
; Note:
; Samples can cross the 32kb bank boundary, however then it is
; necessary that the start position is aligned to a 32-byte interval,
; so that the bank boundary is not crossed in the middle of the buffer.
;======================================================================
	define VERSION "PCM DRIVER V2.0 for MDSDRV"

ASM68K			equ		0
ASMZ80			equ		1
	include "mdssub.inc"

;======================================================================
; VARIABLE USAGE
;----------------------------------------------------------------------
pcm1_regs	equ		$990
pcm1_bank	equ		$991
pcm1_start	equ		$992
pcm1_length	equ		$994

pcm2_regs	equ		$998
pcm2_bank	equ		$999
pcm2_start	equ		$99a
pcm2_length	equ		$99c

stack		equ		$9e0

out_buf1	equ		$960
out_buf2	equ		$9e0

;======================================================================
; REGISTER USAGE
;----------------------------------------------------------------------
;	de		pointer to busy flag (<$100)
;	bc		pointer to mixed PCM buffer
;	hl,ix	FM chip
;	iyh		current bank
;	iyl		current timer reload value
;----------------------------------------------------------------------
;	hl', de', bc' - reserved for the PCM playback routine
;----------------------------------------------------------------------

	org		$0
;======================================================================
; entry point
;----------------------------------------------------------------------
entry
	di
	ld		sp,stack
	xor		a
	jp		main


;======================================================================
; User command handler
;----------------------------------------------------------------------
; TODO: channel 3 helper commands (Probably not as many as the
;       previous driver, but we definitely need a command to set the
;       timer reset command (also the ch3 special enable)

user_cmd
	ret						;first ret set to nop to call user rtn
	exx
	ld		a,$c9							;ret
	ld		(user_cmd),a
	ld		(de),a
	ld		a,(z_fm_reg27)
	ld		(ix+0),$27
	ld		(ix+1),a
	ld		iyl,a
	xor		a
	ld		a,(de)
	exx
	ret

;======================================================================
; Main routine (called from entrypoint)
;----------------------------------------------------------------------
main
	ld		hl,$0900
	ld		de,$0901
	ld		bc,$00ff
	ld		(hl),a
	ldir

	ld		ix,$4000
	ld		hl,$4000
	ld		iy,$ff15

	ld		bc,out_buf1
	ld		a,$fa
	ld		(buf_sign),a					;jp m
	ld		a,low(out_buf2)
	ld		(pcm1_buf),a
	ld		(pcm2_buf),a
	ld		a,$15
	ld		(z_fm_reg27),a

	ld		de,z_busy
	ld		(de),a
	ld		(ix+0),$24						; default timer period
	ld		(ix+1),$ff						; 7670454/(144*(1024-n))
;	ld		(ix+0),$25						; 3fc = 13316 hz
;	ld		(ix+1),$00						;          = ~269 cycles
	ld		(ix+0),$25						; 3fd = 17755 hz
	ld		(ix+1),$01						;          = ~201 cycles
	ld		(ix+0),$27						; timer reset
	ld		(ix+1),$15

;======================================================================
; Idle main routine
;----------------------------------------------------------------------
idle_main
	or		d
	ld		(de),a
	ld		(ix+0),$2a						; default DAC
	ld		(ix+1),$80
	ld		(ix+0),$2b						; disable DAC
	ld		(ix+1),$00
	xor		a
	ld		(de),a
	exx
	ld		hl,z_pcm_key_on

idle_loop
	xor		a
	or		(hl)
	jr		nz,pcm_main
	rst		$08
	jr		idle_loop

;======================================================================
; PCM Main routine
;----------------------------------------------------------------------
pcm_main
	exx
	or		d
	ld		(de),a
	ld		(ix+0),$2b							; enable DAC
	ld		(ix+1),$80
	xor		a
	ld		(de),a
	exx

pcm_loop
	fast_poll											;POLL 1

	; handle flags here
	xor		a
	ld		(hl),a								;reset keyon trigger
	inc		hl
	cp		(hl)
	call	nz, pcm1_key_on
	inc		hl
	cp		(hl)
	call	nz, pcm2_key_on

	fast_poll											;POLL 2

;======================================================================
; PCM1
;----------------------------------------------------------------------
pcm1_main
	ld		a,(z_fm_reg27)
	ld		iyl,a

pcm1_buf		equ		$+1
	ld		de,out_buf2
	ld		a,(z_pcm1_vol)
	or		a
pcm1_enable		equ		$
	jp		pcm1_disabled
	ld		b,a
	fast_poll											;POLL 31

pcm1_abank		equ		$+1
	ld		a,$00
	set_bank
	fast_poll											;POLL 3

pcm1_addr		equ		$+1
	ld		hl,$8000

	dup		7
			read_loop
			inc		e
			fast_poll									;POLL 4-10
	edup

	read_loop
	fast_poll											;POLL 11

	bit		7,h
	jp		nz,.same_bank
	set		7,h
	ld		a,(pcm1_abank)
	inc		a
	ld		(pcm1_abank),a

.same_bank
	ld		(pcm1_addr),hl
	ld		a,(z_pcm1_key_off)
	or		a
	jp		nz,pcm1_key_off

pcm1_left		equ 	$+1
	ld		bc,$0200
	dec		bc
	ld		(pcm1_left),bc
	djnz	pcm2_main
pcm1_key_off
	xor		a
	ld		(z_pcm1_key_off),a

	ld		a,$c3							; change "jp z" to "jp"
	ld		(pcm1_enable),a

;======================================================================
; PCM2 + mix
;----------------------------------------------------------------------
pcm2_main
	ld		a,(z_pcm2_vol)
	or		a
pcm2_enable		equ		$
	jp		pcm2_disabled
	ld		b,a

	ld		a,(z_fm_reg27)
	ld		iyl,a
	fast_poll											;POLL 30

pcm2_abank		equ		$+1
	ld		a,$00
	set_bank
	fast_poll											;POLL 12

pcm2_buf		equ		$+1
	ld		hl,out_buf2
pcm2_addr		equ		$+1
	ld		de,$8000

	dup		15
			read_mix_loop
			inc		l
			fast_poll									;POLL 13-27
	edup

	read_mix_loop
	fast_poll											;POLL 28

	bit		7,d
	jp		nz,.same_bank
	set		7,d
	ld		hl,pcm2_abank
	inc		(hl)

.same_bank
	ld		(pcm2_addr),de
	ld		a,(z_pcm2_key_off)
	or		a
	jp		nz,pcm2_key_off

pcm2_left		equ 	$+1
	ld		bc,$0200
	dec		bc
	ld		(pcm2_left),bc
	djnz	swap_buffers
pcm2_key_off
	xor		a
	ld		(z_pcm2_key_off),a

	ld		a,$c3							; change "jp z" to "jp"
	ld		(pcm2_enable),a
	jr		swap_buffers

;======================================================================
; PCM2 disabled
;----------------------------------------------------------------------
pcm2_disabled
	ld		hl,z_pcm_flag
	res		z_flag_pcm2,(hl)

;======================================================================
; Buffer sync
;----------------------------------------------------------------------
swap_buffers
	ld		a,(pcm1_buf)
	xor		$80
	ld		(pcm1_buf),a
	ld		(pcm2_buf),a
	exx
	faster_poll											;POLL 29

sync_loop
	xor		a					; wait until we can swap the buffer
	or		c					; (when it changes sign)
buf_sign		equ		 $
	jp		m,sync_done
	faster_poll
	jr		sync_loop

sync_done
	ld		a,c					; change to other buffer
	add		$60
	ld		c,a
	exx

	ld		a,(buf_sign)		; alternate between "jp p" and "jp m"
	xor		$08
	ld		(buf_sign),a

	ld		hl,z_pcm_flag
	ld		a,(hl)
	inc		hl
	or		(hl)
	jp		nz,pcm_loop
	exx
	jp		idle_main

;======================================================================
; Read sample parameters from source table.
;======================================================================
	macro	set_src		var,flag
		ld		hl,0
		ld		bc,z_stab
		add		hl,de						;multiply by 6
		add		hl,hl
		add		hl,de
		add		hl,hl
		add		hl,bc
		ld		bc,$0006
		ld		de,var
		ldir
	endm

;======================================================================
; PCM1 key on
;----------------------------------------------------------------------
pcm1_key_on
	ld		(hl),a
	push	hl
	ld		hl,z_pcm1_source
	cp		(hl)
	jr		z,.no_src
	ex		af,af'
	ld		a,(z_pcm1_src)
	ld		d,0
	ld		e,a
	ex		af,af'
	ld		(hl),d
	set_src	pcm1_regs,z_pcm1_source
.no_src
	ld		hl,pcm1_bank
	ld		de,pcm1_abank
	ldi
	ld		de,pcm1_addr
	ldi
	ldi
	ld		de,pcm1_left
	ldi
	ldi
	ld		hl,z_pcm_flag
	set		z_flag_pcm1,(hl)
	ld		(z_pcm1_key_off),a
	ld		hl,pcm1_enable
	ld		(hl),$ca							; change "jp" to "jp z"
	pop		hl
	ret

;======================================================================
; PCM1 disabled - clear back buffer
;----------------------------------------------------------------------
pcm1_disabled
	ld		hl,z_pcm_flag

	res		z_flag_pcm1,(hl)
	fast_poll												;POLL 3
	ld		b,8
.loop
	xor		a
	dup		4
		ld		(de),a
		inc		e
	edup
	fast_poll												;POLL 4-11
	djnz	.loop
	jp		pcm2_main

;======================================================================
; PCM2 key on
;----------------------------------------------------------------------
pcm2_key_on
	ld		(hl),a
	push	hl
	ld		hl,z_pcm2_source
	cp		(hl)
	jr		z,.no_src
	ex		af,af'
	ld		a,(z_pcm2_src)
	ld		d,0
	ld		e,a
	ex		af,af'
	ld		(hl),d
	set_src	pcm2_regs,z_pcm2_source
.no_src
	ld		hl,pcm2_bank
	ld		de,pcm2_abank
	ldi
	ld		de,pcm2_addr
	ldi
	ldi
	ld		de,pcm2_left
	ldi
	ldi
	ld		hl,z_pcm_flag
	set		z_flag_pcm2,(hl)
	ld		(z_pcm2_key_off),a
	ld		hl,pcm2_enable
	ld		(hl),$ca							; change "jp" to "jp z"
	pop		hl
	ret

	assert		$ <= out_buf1				; Maximum program size
	assert		user_cmd = $08				; User command trigger
	db		VERSION

; vim: set ft=z8a sw=4 ts=4 noet: